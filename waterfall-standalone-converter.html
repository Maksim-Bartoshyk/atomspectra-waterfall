<html>
	<head>
		<style>
		</style>
		<script>
			window.exports = {};
		</script>
		<script>
			// contents of spectrum.js
			exports.deserializeSpectrum = function(fileText) {
				if (!fileText) {
					throw new Error('spectrum file text is empty');
				}

				const lines = fileText.split('\n');
				const format = lines[0];
				const note = lines[1];
				const time = parseInt(lines[2]);
				const time2 = parseInt(lines[3]);
				const latStr = lines[4];
				const lonStr = lines[5];
				const name = lines[6];
				const foundIsotopes = lines[7];
				const duration = parseFloat(lines[8]);
				const channelsCount = parseInt(lines[9]);
				const calibrationOrder = parseInt(lines[10]);
				const calibration = [];
				for (let i = 0; i < calibrationOrder + 1; i++) {
					calibration.push(parseFloat(lines[11 + i]));
				}

				let index = 0;
				const channels = [];
				while (index < channelsCount) {
					channels.push(parseInt(lines[12 + calibrationOrder + index]));
					index++;
				}

				return {
					format: format,
					note: note,
					timestamp: time,
					timestamp2: time2,
					latStr: latStr,
					lonStr: lonStr,
					name: name,
					foundIsotopes: foundIsotopes,
					duration: duration,
					channelCount: channels.length,
					calibration: calibration,
					channels: channels
				};
			}

			exports.serializeSpectrum = function(spectrum) {
				if (!spectrum) {
					throw new Error('spectrum is not provided');
				}

				let text = spectrum.format + '\n';
				text += spectrum.note + '\n';
				text += spectrum.timestamp + '\n';
				text += spectrum.timestamp2 + '\n';
				text += spectrum.latStr + '\n';
				text += spectrum.lonStr + '\n';
				text += spectrum.name + '\n';
				text += spectrum.foundIsotopes + '\n';
				text += spectrum.duration + '\n';
				text += spectrum.channelCount + '\n';
				text += (spectrum.calibration.length - 1) + '\n';
				for (let i = 0; i < spectrum.calibration.length; i++) {
					text += spectrum.calibration[i] + '\n';
				}

				let index = 0;
				while (index < spectrum.channelCount) {
					text += spectrum.channels[index] + '\n';
					index++;
				}

				return text;
			}

			exports.deserializeDeltas = function(fileText, baseSpectrum) {
				if (!fileText) {
					throw new Error('spectrum file text is empty');
				}

				const lines = fileText.split('\n');
				const deltaLinesCount = 5;
				const deltas = [];
				let deltaIndex = baseSpectrum.calibration.length + baseSpectrum.channelCount + 11; // skip base spectrum
				while (deltaIndex <= lines.length - deltaLinesCount) {
					const delta = readNextDelta(lines, deltaIndex, baseSpectrum.channelCount);
					deltas.push(delta);
					deltaIndex += deltaLinesCount;
				}

				return {
					deltas: deltas
				};
			}

			exports.reduceSpectrumCount = function(spectrums, factor) {
				if (factor < 1) {
					throw new Error('invalid factor: ' + factor);
				}

				if (!spectrums || !spectrums.length) {
					throw new Error('no spectrums provided');
				}

				let reduced = [];
				for (let i = 0; i < spectrums.length; i += factor) {
					let summ = { ...spectrums[i] };
					for (let j = 1; j < factor && (i + j) < spectrums.length; j++) {
						for (let k = 0; k < summ.channels.length; k++) {
							summ.channels[k] += spectrums[i + j].channels[k];
						}

						summ.duration += spectrums[i + j].duration;
					}

					reduced.push(summ);
				}

				return reduced;
			}

			exports.reduceChannelCount = function(channels, factor) {
				if (factor < 1) {
					throw new Error('invalid factor: ' + factor);
				}

				if (!channels || !channels.length) {
					throw new Error('no channels provided');
				}

				let reduced = [];
				for (let i = 0; i < channels.length; i += factor) {
					let summ = 0;
					for (let j = 0; j < factor && (i + j) < channels.length; j++) {
						summ += channels[i + j];
					}

					reduced.push(summ);
				}

				return reduced;
			}

			exports.getCalibration = function (calibration, channelReduceFactor) {
				const newCalibration = [];
				for (let i = 0; i < calibration.length; i++) {
					newCalibration.push(Math.pow(channelReduceFactor, i) * calibration[i]);
				}

				return newCalibration;
			}

			function readNextDelta(lines, fromIndex, channelCount) {
				const timestamp = parseInt(lines[fromIndex]);
				const lat = parseFloat(lines[fromIndex + 1]);
				const lon = parseFloat(lines[fromIndex + 2]);
				const duration = parseFloat(lines[fromIndex + 3]);
				const channels = lines[fromIndex + 4]
					.split('\t')
					.slice(0, channelCount)
					.map(str => parseInt(str));

				return {
					timestamp: timestamp,
					duration: duration,
					lat: lat,
					lon: lon,
					channels: channels
				}
			}
		</script>
		<script>
			// contents of radiacode.js
			exports.createRcspgData = function(baseSpectrum, deltas) {
				if (!baseSpectrum || !deltas || deltas.length === 0) {
					throw new Error('no deltas provided for rcspg convertion')
				}

				const fromTimestamp = deltas[0].timestamp;
				const toTimestamp = deltas[deltas.length - 1].timestamp;

				// header
				const utcISO = new Date(fromTimestamp).toISOString();
				const formattedUTC = utcISO.split('T').join(' ').split('.')[0] + ' UTC';
				const spgName = baseSpectrum.name;
				const spgTime = formattedUTC;
				let rcspgData = 'Spectrogram: ' + spgName + 
								'\tTime: ' + spgTime + 
								'\tTimestamp: ' + filetimeFromJSTime(fromTimestamp) + // just in case to avoid any potential division by zero
								'\tAccumulation time: ' + Math.floor((toTimestamp - fromTimestamp) / 1000) + 
								'\tChannels: 1024\tDevice serial: unknown\tFlags: 1\tComment: exported from atomspectra data';

				const calibration = exports.getCalibration(baseSpectrum.calibration, 8);
				// base spectrum, zero duration, y=x calibration, all zero channels
				let a0 = 0;
				let a1 = 1;
				let a2 = 0;
				switch (calibration.length) {
					case 2:
						a0 = calibration[0];
						a1 = calibration[1];
						break;
					case 3:
						a0 = calibration[0];
						a1 = calibration[1];
						a2 = calibration[2];
						break;
					default:
						console.warn('calibration polynom order (' + calibration.length + ') is not supported, y=x applied');
				}

				// TODO: write base spectrum
				rcspgData += '\nSpectrum: ' +
							/*int32 duration*/'00 00 00 00' + ' ' +
							/*float A0*/getBigEndianFloat(a0) + ' ' +
							/*float A1*/getBigEndianFloat(a1) + ' ' +
							/*float A2*/getBigEndianFloat(a2) + ' ' +
							Array(1024).fill('00 00 00 00').join(' ');

				// deltas
				deltas.forEach(delta => {
					const channels = exports.reduceChannelCount(delta.channels, 8);
					rcspgData += '\n' + filetimeFromJSTime(delta.timestamp);
					rcspgData += '\t' + Math.round(delta.duration);
					channels.forEach(channel => {
					rcspgData += '\t' + channel;
					});
				});

				return rcspgData;
			}

			function getBigEndianFloat(value) {
				const getHex = i => ('00' + i.toString(16)).slice(-2);

				var view = new DataView(new ArrayBuffer(4));
				view.setFloat32(0, value);
				const result = Array
					.apply(null, { length: 4 })
					.map((_, i) => getHex(view.getUint8(i)))
					.reverse()
					.join(' ');

				return result;
			}

			function filetimeFromJSTime(jsTime) {  
				return jsTime * 1e4 + 116444736e9;
			}
		</script>
	</head>
	<body>
		<input id="upload" type="file" accept=".txt" name="files" onchange="onFileChange(this)">
		<script>
			window.onerror = (e) => {
				alert(e);
			};

			// file upload
			function onFileChange(input) {
				const file = input.files[0];
				const reader = new FileReader();
				reader.onload = (e) => {
					const fileText = e.target.result;
					const baseSpectrum = exports.deserializeSpectrum(fileText);
					const deltaInfo = exports.deserializeDeltas(fileText, baseSpectrum);
					const deltas = deltaInfo.deltas;

					const rcspgData = exports.createRcspgData(baseSpectrum, deltas);
					saveRcspg(file.name.split('.')[0] + '.rcspg', rcspgData);
					alert('Done.');
				};

				reader.readAsText(file);
			}

			function saveRcspg(filename, data) {
				const blob = new Blob([data], {type: 'text/plain'});
				const elem = window.document.createElement('a');
				elem.href = window.URL.createObjectURL(blob);
				elem.download = filename;
				document.body.appendChild(elem);
				elem.click();
				document.body.removeChild(elem);
			}
		</script>
	</body>
</html>