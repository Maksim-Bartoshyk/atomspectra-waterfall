<html>
	<head>
		<title>AS Waterfall v2024.12.18</title>
		<style>body {
    background: #444;
    box-sizing: border-box;
    color: #CCC;
    margin: 0;
    min-width: 1024px;
    padding: 0 12px;
    scrollbar-color: #444 #888;
}
body * {
    box-sizing: border-box;
    font-size: 16px;
    font-family: sans-serif;
    margin: 0;
    padding: 0;
}
select, input {
    background: #444;
    color: #CCC;
}
input[type="number"] {
    border: 1px solid #CCC;
    padding-left: 4px;
}
input[type="checkbox"], input[type="radio"] {
    margin: 3px 3px 3px 0;
}
.blocking-overlay {
    position: absolute;
    background: rgba(100, 100, 100, 0.75);
    top: 40px;
    bottom: 0;
    left: 0;
    right: 0;
    min-width: 1024px;
}
@keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
}
.status-text.fadein {
    animation: fadeIn 0.25s;
}
.status-text {
    background: lightgray;
    border: 1px solid white;
    color: black;
    display: none;
    left: 500px;
    padding: 8px;
    position: absolute;
    top: 50%;
    width: fit-content;
    z-index: 1;
}
.upload-control {
    border-bottom: 1px dotted;
    padding-top: 12px;
    padding-bottom: 4px;
    text-wrap: nowrap;
}
.upload-control * {
    display: inline-block;
}
.upload-control .file-input {
    width: 580px;
}
.waterfall-control, .cps-control {
    width: 100%;
    border-bottom: 1px dotted;
}
.waterfall-control {
    padding-top: 12px;
}
.col .timezone {
    width: 97px;
    text-align: right;
}
.col .palette {
    width: 68px;
}
.row {
    display: flex;
    justify-content: space-between;
    max-width: 1000px;
    padding-bottom: 8px;
}
.col {
    align-items: baseline;
    display: inline-flex;
    width: 175px;
}
.col label {
    flex-grow: 1;
}
.col input[type="number"], .col select {
    width: 64px;
}
.scale-switch {
    display: inline-block;
    margin-right: 16px;
}
.preview-container {
    display: none;
    height: 125px;
    max-width: calc(100% - 320px);
    overflow-x: hidden;
    overflow-y: scroll;
    padding-left: 150px;
    scrollbar-color: #444 #444;
    width: fit-content;
}
.plot-container, .plot-container .cps-container {
    height: calc(100% - 212px); /* - other controls height */
}
.plot-container.with-preview, .plot-container.with-preview .cps-container {
    height: calc(100% - 212px - 125px); /* - other controls height + preview heigth */
}
.plot-container .waterfall-container {
    display: inline-block;
    height: 100%;
    max-width: calc(100% - 320px); /* cpsPlotWidth in js + scroll */
    overflow-x: scroll;
    overflow-y: scroll;
}
.plot-container .cps-container {
    display: inline-block;
    position: absolute;
    overflow-y: scroll;
    overflow-x: scroll;
    padding-left: 1px;
    width: 320px; /* cpsPlotWidth in js + scroll */
}
.cps-container .cps-plot {
    position: absolute;
    transform: rotate(90deg); /* veeeeeery hacky, need to rewrite this */
    transform-origin: bottom left;
    top: -300px; /* cpsPlotWidth in js */
}
.horizontal-cursor, .vertical-cursor {
    display: none;
    position: absolute;
    z-index: 1;
}
.horizontal-cursor {
    border-bottom: 1px dotted #777;
    height: 0;
}
.vertical-cursor {
    border-right: 1px dotted #777;
    width: 0;
}
.cps-control {
    padding-top: 8px;
}
.cps-control .numeric-input {
    margin: 0 4px;
    width: 150px;
}
.cps-left-column {
    display: inline-block;
    width: 330px;
}
.export-button {
    width: 340px;
}
.spg-range-button {
    width: 169px;
}
.error {
    color: orangered;
}
</style>
		<script>
			(function () {
				// error console
				window.onerror = function(msg, url, lineNo, columnNo, error) {
					addError(msg + ' (line: ' + lineNo + ', column: ' + columnNo + ')');
				};

				window.addEventListener("unhandledrejection", function (e) {
					addError(e.reason.stack);
				});

				function addError(msg) {
					const div = document.createElement('div');
					div.className = "row error";
					div.innerText = msg;
					document.body.appendChild(div);
				}
			})();
		</script>
		<script>
			window.originalWaterfallData = 'waterfall-data-placeholder';
			window.exports = {}; // hack to re-use nodejs modules
			window.require = () => window.exports;
		</script>
		<script>// TODO: try use typed array to optimize memory consumption (float32, for instance)
(function () {
	exports.deserializeSpectrum = function(fileText) {
		if (!fileText) {
			throw new Error('spectrum file text is empty');
		}
	
		const lines = fileText.split('\n');
		const format = lines[0];
		const note = lines[1];
		const time = parseInt(lines[2]);
		const time2 = parseInt(lines[3]);
		const latStr = lines[4];
		const lonStr = lines[5];
		const name = lines[6];
		const foundIsotopes = lines[7];
		const duration = parseFloat(lines[8]);
		const channelsCount = parseInt(lines[9]);
		const calibrationOrder = parseInt(lines[10]);
		const calibration = [];
		for (let i = 0; i < calibrationOrder + 1; i++) {
			calibration.push(parseFloat(lines[11 + i]));
		}
	
		let index = 0;
		const channels = new Float32Array(channelsCount);
		while (index < channelsCount) {
			channels[index] = parseFloat(lines[12 + calibrationOrder + index]);
			index++;
		}
	
		return {
			format: format,
			note: note,
			timestamp: time,
			timestamp2: time2,
			latStr: latStr,
			lonStr: lonStr,
			name: name,
			foundIsotopes: foundIsotopes,
			duration: duration,
			channelCount: channels.length,
			calibration: calibration,
			channels: channels
		};
	}
	
	exports.serializeSpectrum = function(spectrum) {
		if (!spectrum) {
			throw new Error('spectrum is not provided');
		}
	
		let text = spectrum.format + '\n';
		text += spectrum.note + '\n';
		text += spectrum.timestamp + '\n';
		text += spectrum.timestamp2 + '\n';
		text += spectrum.latStr + '\n';
		text += spectrum.lonStr + '\n';
		text += spectrum.name + '\n';
		text += spectrum.foundIsotopes + '\n';
		text += spectrum.duration + '\n';
		text += spectrum.channelCount + '\n';
		text += (spectrum.calibration.length - 1) + '\n';
		for (let i = 0; i < spectrum.calibration.length; i++) {
			text += spectrum.calibration[i] + '\n';
		}
	
		let index = 0;
		while (index < spectrum.channelCount) {
			text += spectrum.channels[index] + '\n';
			index++;
		}
	
		return text;
	}
	
	exports.deserializeDeltas = function(fileText, baseSpectrum) {
		if (!fileText) {
			throw new Error('spectrum file text is empty');
		}
	
		const lines = fileText.split('\n');
		const deltaLinesCount = 5;
		const deltas = [];
		let deltaIndex = baseSpectrum.calibration.length + baseSpectrum.channelCount + 11; // skip base spectrum
		while (deltaIndex <= lines.length - deltaLinesCount) {
			const delta = readNextDelta(lines, deltaIndex, baseSpectrum.channelCount);
			deltas.push(delta);
			deltaIndex += deltaLinesCount;
		}
	
		return {
			deltas: deltas
		};
	}
	
	exports.reduceSpectrumCount = function(spectrums, spectrumsBinning) {
		if (spectrumsBinning < 1) {
			throw new Error('invalid factor: ' + spectrumsBinning);
		}
	
		if (!spectrums || !spectrums.length) {
			throw new Error('no spectrums provided');
		}
	
		let reduced = [];
		for (let i = 0; i < spectrums.length; i += spectrumsBinning) {
			let summ = { 
				...spectrums[i],
				channels: new Float32Array(spectrums[i].channels) 
			};
			for (let j = 1; j < spectrumsBinning && (i + j) < spectrums.length; j++) {
				for (let k = 0; k < summ.channels.length; k++) {
					summ.channels[k] += spectrums[i + j].channels[k];
				}
	
				summ.duration += spectrums[i + j].duration;
			}
	
			reduced.push(summ);
		}
	
		return reduced;
	}
	
	exports.reduceChannelCount = function(channels, channelBinning) {
		if (channelBinning < 1) {
			throw new Error('invalid channel binning: ' + channelBinning);
		}
	
		if (!channels || !channels.length) {
			throw new Error('no channels provided');
		}
	
		let reduced = [];
		for (let i = 0; i < channels.length; i += channelBinning) {
			let summ = 0;
			for (let j = 0; j < channelBinning && (i + j) < channels.length; j++) {
				summ += channels[i + j];
			}
	
			reduced.push(summ);
		}
	
		return new Float32Array(reduced);
	}
	
	exports.getCalibration = function (calibration, channelBinning) {
		const newCalibration = [];
		for (let i = 0; i < calibration.length; i++) {
			newCalibration.push(Math.pow(channelBinning, i) * calibration[i]);
		}
	
		return newCalibration;
	}

	exports.combineSpectrums = function(deltas, fromIndex, toIndex, baseSpectrum, filename) {
		if (fromIndex < 0) {
			fromIndex = 0;
		}

		if (toIndex > deltas.length - 1) {
			toIndex = deltas.length - 1;
		}

		if (fromIndex > toIndex) {
			const tmp = fromIndex;
			fromIndex = toIndex;
			toIndex = tmp;
		}

		const deltasToCombine = deltas.slice(fromIndex, toIndex + 1);
		const combinedDelta = this.reduceSpectrumCount(deltasToCombine, deltasToCombine.length)[0];
		const combinedSpectrum = {
			format: 'FORMAT: 3',
			note: 'Counts: ' + combinedDelta.channels.reduce((a, v) => a += v, 0) + ', '
				+ 'combined from spectrogram ' + filename + ', '
				+ 'from index: ' + fromIndex + ', '
				+ 'to index: ' + toIndex + ', '
				+ 'from time: ' + formatTime(deltas[fromIndex].timestamp) + ', '
				+ 'to time: ' + formatTime(deltas[toIndex].timestamp),
			timestamp: combinedDelta.timestamp,
			timestamp2: '0',
			latStr: '0.0',
			lonStr: '0.0',
			name: baseSpectrum.name,
			foundIsotopes: '',
			duration: combinedDelta.duration,
			channelCount: combinedDelta.channels.length,
			calibration: baseSpectrum.calibration,
			channels: combinedDelta.channels
		};
		
		return combinedSpectrum;
	}
	
	function readNextDelta(lines, fromIndex, channelCount) {
		const timestamp = parseInt(lines[fromIndex]);
		const lat = parseFloat(lines[fromIndex + 1]);
		const lon = parseFloat(lines[fromIndex + 2]);
		const duration = parseFloat(lines[fromIndex + 3]);
		const channels = new Float32Array(channelCount);
		lines[fromIndex + 4]
			.split('\t')
			.slice(0, channelCount)
			.forEach((str, index) => channels[index] = parseFloat(str));
	
		return {
			timestamp: timestamp,
			duration: duration,
			lat: lat,
			lon: lon,
			channels: channels
		}
	}
	
	function formatTime(timestamp) {
		const utcISO = new Date(timestamp).toISOString();

		return utcISO.split('T').join(' ').split('.')[0] + ' UTC';
	}
})();
</script>
		<script>(function(){
	const sp = require('./spectrum.js');

	exports.createWaterfallData = function(baseSpectrum, deltas, channelBinning, spectrumBinning, filename) {
		const baseChannels = sp.reduceChannelCount(baseSpectrum.channels, channelBinning);
		let waterfall = {
			deltas: [],
			baseSpectrum: {
				...baseSpectrum,
				channels: baseChannels,
				channelCount: baseChannels.length,
				calibration: sp.getCalibration(baseSpectrum.calibration, channelBinning)
			},
			channelBinning: channelBinning,
			spectrumBinning: spectrumBinning,
			filename: filename
		};

		sp.reduceSpectrumCount(deltas, spectrumBinning).forEach(delta8k => {
			waterfall.deltas.push({
				...delta8k,
				channels: sp.reduceChannelCount(delta8k.channels, channelBinning)
			});
		});

		return waterfall;
	}
})();
</script>
		<script>(function () {
	const sp = require('./spectrum.js');

	exports.createRcspgData = function(baseSpectrum, deltas) {
		if (!baseSpectrum || !deltas || deltas.length === 0) {
			throw new Error('no deltas provided for rcspg convertion')
		}

		const fromTimestamp = deltas[0].timestamp;
		const toTimestamp = deltas[deltas.length - 1].timestamp;

		// header
		const utcISO = new Date(fromTimestamp).toISOString();
		const formattedUTC = utcISO.split('T').join(' ').split('.')[0] + ' UTC';
		const spgName = baseSpectrum.name;
		const spgTime = formattedUTC;
		let rcspgData = 'Spectrogram: ' + spgName + 
						'\tTime: ' + spgTime + 
						'\tTimestamp: ' + filetimeFromJSTime(fromTimestamp) + // just in case to avoid any potential division by zero
						'\tAccumulation time: ' + Math.floor((toTimestamp - fromTimestamp) / 1000) + 
						'\tChannels: 1024\tDevice serial: unknown\tFlags: 1\tComment: exported from atomspectra data';

		const calibration = sp.getCalibration(baseSpectrum.calibration, 8);
		// base spectrum, zero duration, y=x calibration, all zero channels
		let a0 = 0;
		let a1 = 1;
		let a2 = 0;
		switch (calibration.length) {
			case 2:
				a0 = calibration[0];
				a1 = calibration[1];
				break;
			case 3:
				a0 = calibration[0];
				a1 = calibration[1];
				a2 = calibration[2];
				break;
			default:
				console.warn('calibration polynom order (' + calibration.length + ') is not supported, y=x applied');
		}

		// TODO: write base spectrum
		rcspgData += '\nSpectrum: ' +
					/*int32 duration*/'00 00 00 00' + ' ' +
					/*float A0*/getBigEndianFloat(a0) + ' ' +
					/*float A1*/getBigEndianFloat(a1) + ' ' +
					/*float A2*/getBigEndianFloat(a2) + ' ' +
					Array(1024).fill('00 00 00 00').join(' ');

		// deltas
		deltas.forEach(delta => {
			const channels = sp.reduceChannelCount(delta.channels, 8);
			rcspgData += '\n' + filetimeFromJSTime(delta.timestamp);
			rcspgData += '\t' + Math.round(delta.duration);
			channels.forEach(channel => {
			rcspgData += '\t' + channel;
			});
		});

		return rcspgData;
	}

	exports.getRctrkData = function(name, deltas, range1, range2, channelBin) {
		let rctrkData = 'Track: ' + name + '\tAtom Spectra spectrogram\t \tEC\n';
		rctrkData += 'Timestamp\tTime\tLatitude\tLongitude\tAccuracy\tDoseRate\tCountRate\tComment\n';
		deltas.forEach(delta8k => {
			const channels = sp.reduceChannelCount(delta8k.channels, channelBin);
			let newLine = '';
			// ex: '133594869443100000	2024-05-06 16:35:44	60.0006352	30.3515997	6.79	13.3	9.98	 '
			newLine += filetimeFromJSTime(delta8k.timestamp).toString() + '\t';
			newLine += formatDate(delta8k.timestamp) + '\t';
			newLine += delta8k.lat.toFixed(8) + '\t';
			newLine += delta8k.lon.toFixed(8) + '\t';
			newLine += '0.0\t'; // accuracy
			newLine += '0.0\t'; // doserate
			let cps = cpsInRange(channels, delta8k.duration, range1);
			if (range2) {
				let cps2 = cpsInRange(channels, delta8k.duration, range2);
				if (cps2 > 0) {
					cps /= cps2;
				} else {
					cps = 0;
				}
			} 
			newLine += cps.toFixed(4) + '\t'; // cps
			newLine += ' \n'; // comment

			if (cps > 0 && (delta8k.lat !== 0 && delta8k.lon !== 0)) {
				rctrkData += newLine;
			}
		});

		return rctrkData;
	}

	function getBigEndianFloat(value) {
		const getHex = i => ('00' + i.toString(16)).slice(-2);

		var view = new DataView(new ArrayBuffer(4));
		view.setFloat32(0, value);
		const result = Array
			.apply(null, { length: 4 })
			.map((_, i) => getHex(view.getUint8(i)))
			.reverse()
			.join(' ');

		return result;
	}

	function filetimeFromJSTime(jsTime) {  
		return jsTime * 1e4 + 116444736e9;
	}

	function formatDate(ts) {
		const splitDate = new Date(ts).toISOString().split('T');

		return splitDate[0] + ' ' + splitDate[1].split('.')[0];
	}

	function cpsInRange(channels, duration, range) {
		return channels.slice(range[0], range[1] + 1).reduce((a, v) => a + v, 0) / duration;
	}
})();</script> <!-- to be replaced with atom.js -->
	</head>
	<body>
		<div id="blocking-overlay" class="blocking-overlay"></div>
		<div id="status-text" class="status-text">...</div>
		<div id="upload-control" class="upload-control">
			<span>Atomspectra file:</span>
			<input id="file-input" class="file-input" type="file" accept=".txt" name="files">
			<label for="import-channel-binning">Import channel binning:</label>
			<select name="import-channel-binning" id="import-channel-binning">
				<option value="1">1</option>
				<option value="2">2</option>
				<option value="4" selected>4</option>
				<option value="8">8</option>
				<option value="16">16</option>
				<option value="32">32</option>
			</select>
			| <input type="checkbox" id="v-6.6.14" name="v-6.6.14"/>
			<label for="v-6.6.14">6.6.14</label>
		</div>
		<div id="file-info-container" class="upload-control">
			<span id="file-info"></span>
		</div>
		<div id="waterfall-control" class="waterfall-control">
			<div class="row">
				<div class="col">
					<input type="radio" id="lin" name="scale" value="lin">
					<label for="lin">LIN</label>
					<input type="radio" id="sqrt" name="scale" value="sqrt" checked>
					<label for="sqrt">SQRT</label>
					<input type="radio" id="log" name="scale" value="log">
					<label for="log">LOG</label>
				</div>
				<div class="col">
					<input type="checkbox" id="blur-waterfall" name="blur-waterfall"/>
					<label for="blur-waterfall">Blur waterfall image</label>
				</div>
				<div class="col">
					<label for="spectrum-binning">Spectrum bin:</label>
					<input type="number" min="1" value="1" name="spectrum-binning" id="spectrum-binning"/>
				</div>
				<div class="col">
					<label for="max-cps">Scale max(%):</label>
					<input type="number" name="max-cps" id="max-cps" min="0" max="100" step="10" value="100"/>
				</div>
				<div class="col">
					<label for="moving-average-vertical">Moving avg(v):</label>
					<select name="moving-average-vertical" id="moving-average-vertical">
						<option value="0">0</option>
						<option value="2">2</option>
						<option value="4">4</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
				</div>
			</div>
			<div class="row">
				<div class="col">
					<select name="palette" id="palette" class="palette">
						<option value="iron" selected>Iron</option>
						<option value="lime">Lime</option>
						<option value="yellow">Yellow</option>
						<option value="glow">Glow</option>
						<option value="gray">Gray</option>
					</select>
					&nbsp;
					<select name="timezone" id="timezone" class="timezone">
						<option value="-11">-11 h</option>
						<option value="-10">-10 h</option>
						<option value="-9">-9 h</option>
						<option value="-8">-8 h</option>
						<option value="-7">-7 h</option>
						<option value="-6">-6 h</option>
						<option value="-5">-5 h</option>
						<option value="-4">-4 h</option>
						<option value="-3">-3 h</option>
						<option value="-2">-2 h</option>
						<option value="-1">-1 h</option>
						<option value="0">UTC</option>
						<option value="local" selected>Local time</option>
						<option value="1">+1 h</option>
						<option value="2">+2 h</option>
						<option value="3">+3 h</option>
						<option value="4">+4 h</option>
						<option value="5">+5 h</option>
						<option value="6">+6 h</option>
						<option value="7">+7 h</option>
						<option value="8">+8 h</option>
						<option value="9">+9 h</option>
						<option value="10">+10 h</option>
						<option value="11">+11 h</option>
						<option value="12">+12 h</option>
					</select>
				</div>
				<div class="col">
					<input type="checkbox" id="subtract-base" name="subtract-base"/>
					<label for="subtract-base" id="subtract-base-label">Subtract base</label>
				</div>
				<div class="col">
					<label for="channel-binning">Channel bin:</label>
					<select name="channel-binning" id="channel-binning">
						<option value="1">1</option>
						<option value="2">2</option>
						<option value="4">4</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
				</div>
				<div class="col">
					<label for="min-cps">Scale min(%):</label>
					<input type="number" name="min-cps" id="min-cps" min="0" max="99" step="1" value="0"/>
				</div>
				<div class="col">
					<label for="moving-average-horizontal">Moving avg(h):</label>
					<select name="moving-average-horizontal" id="moving-average-horizontal">
						<option value="0">0</option>
						<option value="2">2</option>
						<option value="4">4</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
				</div>
			</div>
		</div>
		<div id="preview-container" class="preview-container">
			<canvas id="preview-plot" class="plot" width="662" height="0"></canvas>
		</div>
		<div id="plot-container" class="plot-container">
			<div id="horizontal-cursor" class="horizontal-cursor"></div>
			<div id="vertical-cursor" class="vertical-cursor"></div>
			<div id="waterfall-container" class="waterfall-container">
				<canvas id="waterfall-plot" class="plot" width="662" height="0"></canvas>
			</div>
			<div id="cps-container" class="cps-container">
				<canvas id="cps-plot" class="cps-plot" width="0" height="0"></canvas>
			</div>
		</div>
		<div id="cps-control" class="cps-control">
			<div class="row">
				<label id="render-cps" class="cps-left-column">CPS trend in channel range_1:</label> 
				<input type="number" id="from-channel-1" class="numeric-input"/>-<input type="number" id="to-channel-1" class="numeric-input"/>
				<button id="export-cps-map" class="export-button" disabled>Range_1 cps to map</button>
			</div>
			<div class="row">
				<div class="cps-left-column">
					<input type="checkbox" id="cps-comparison" name="cps-comparison"/>
					<label for="cps-comparison">Compare to CPS in channel range_2:</label>
				</div>
				<input type="number" id="from-channel-2" class="numeric-input"/>-<input type="number" id="to-channel-2" class="numeric-input"/>
				<button id="export-comparison-map" class="export-button" disabled>Range_1/range_2 comparison to map</button>
			</div>
			<div class="row">
				<div class="cps-left-column">
					<input type="checkbox" id="preview-enabled" name="preview-enabled"/>
					<label for="preview-enabled">Preview spectrum in spectrorgam range:</label>
				</div>
				<input type="number" id="from-spectrum" class="numeric-input" placeholder="from index"/>-<input type="number" id="to-spectrum" class="numeric-input" placeholder="to index"/>
				<button id="spg-range-as-base" class="spg-range-button">Spg range as base</button>
				<button id="spg-range-to-file" class="spg-range-button">Spg range to file</button>
			</div>
		</div>
		<script>(function () {
    const statusText = document.getElementById('status-text');

    // display configuration/state
    window.constants = {
        timeAxisWidth: 150, // note: the same in css
        timestampHeight: 20,
        timestampTickWidth: 10,
        channelAxisHeight: 32,
        channelAxisTickHeight: 4,
        backgroundColor: 'black',
        previewHeight: 125,
        textColor: 'lightgray',
        lineColor: 'lightgray',
        separatorLineColor: '#777777',
        dotColor: 'white',
        cpsPlotHeight: 300,
        cpsExtendRange: 0.1,
        blurRadius: 1,
        cursorOffset: 3,
    };
    window.waterfallState = {
        scale: 'sqrt',
        palette: 'iron',
        spectrumBinning: 1,
        channelBinning: 1,
        blur: false,
        subtractBase: false,
        movingAverageVertical: 0,
        movingAverageHorizontal: 0,
        maxCpsPercent: 100,
        minCpsPercent: 0,
        timeOffsetHours: getLocalTimeOffsetHours(),
        previewEnebled: false,
        channelRange1: [],
        channelRange2: [],
        spectrumRange: [],
    };
    window.common = {
        timeToString: timestamp => {
            const utcISO = new Date(timestamp + waterfallState.timeOffsetHours * 60 * 60 * 1000).toISOString();
            let offsetStr;
            if (waterfallState.timeOffsetHours > 0) {
                offsetStr = '+' + waterfallState.timeOffsetHours + 'h';
            } else if (waterfallState.timeOffsetHours < 0) {
                offsetStr = '' + waterfallState.timeOffsetHours + 'h';
            } else {
                offsetStr = 'UTC';
            }

            return utcISO.split('T').join(' ').split('.')[0] + ' ' + offsetStr;
        },
        channelToEnergy: channel => {
            return waterfallData.baseSpectrum.calibration.reduce((e, c, i) => e += Math.pow(channel, i) * c, 0);
        },
        getLocalTimeOffsetHours: () => getLocalTimeOffsetHours(),
        executeWithStatusAsync: (status, func) => executeWithStatusAsync(status, func),
    }

    function getLocalTimeOffsetHours() {
        return -(new Date().getTimezoneOffset() / 60);
    }

    let hideOverlayTimeout = -1;
    function executeWithStatusAsync(status, func) {
        return new Promise((res, rej) => {
            setTimeout(() => {
                clearTimeout(hideOverlayTimeout);
                statusText.innerText = status;
                statusText.style.display = 'block';
                statusText.classList.add('fadein');

                setTimeout(() => {
                    try {
                        func();
                        res();
                    } catch(e) {
                        rej(e);
                    } finally {
                        hideOverlayTimeout = setTimeout(() => { // debounce time to avoid flickering
                            statusText.innerText = '';
                            statusText.classList.remove('fadein');
                            statusText.style.display = 'none';
                        }, 250);
                    }
                }, 25); // let status to be rendered
            }, 0);
        });
    }
})();
</script>
		<script>(function(){
    // waterfall plot render
    window.waterfall = {
        renderWaterfallImage: () => renderWaterfallImage(),
        renderWaterfallImageAsync: () => {
            return common.executeWithStatusAsync('Rendering waterfall...', () => renderWaterfallImage());
        },
        renderSpectrumImage: () => renderSpectrumImage(),
        renderSpectrumImageAsync: () => {
            if (!waterfallState.previewEnabled) {
                return new Promise((r) => r());
            }

            return common.executeWithStatusAsync('Rendering spectrum...', () => {
                renderSpectrumImage();
            });
        },
    }

    const ironPaletteHex = ["#00000a","#000014","#00001e","#000025","#00002a","#00002e","#000032","#000036","#00003a","#00003e","#000042","#000046","#00004a","#00004f","#000052","#010055","#010057","#020059","#02005c","#03005e","#040061","#040063","#050065","#060067","#070069","#08006b","#09006e","#0a0070","#0b0073","#0c0074","#0d0075","#0d0076","#0e0077","#100078","#120079","#13007b","#15007c","#17007d","#19007e","#1b0080","#1c0081","#1e0083","#200084","#220085","#240086","#260087","#280089","#2a0089","#2c008a","#2e008b","#30008c","#32008d","#34008e","#36008e","#38008f","#390090","#3b0091","#3c0092","#3e0093","#3f0093","#410094","#420095","#440095","#450096","#470096","#490096","#4a0096","#4c0097","#4e0097","#4f0097","#510097","#520098","#540098","#560098","#580099","#5a0099","#5c0099","#5d009a","#5f009a","#61009b","#63009b","#64009b","#66009b","#68009b","#6a009b","#6c009c","#6d009c","#6f009c","#70009c","#71009d","#73009d","#75009d","#77009d","#78009d","#7a009d","#7c009d","#7e009d","#7f009d","#81009d","#83009d","#84009d","#86009d","#87009d","#89009d","#8a009d","#8b009d","#8d009d","#8f009c","#91009c","#93009c","#95009c","#96009b","#98009b","#99009b","#9b009b","#9c009b","#9d009b","#9f009b","#a0009b","#a2009b","#a3009b","#a4009b","#a6009a","#a7009a","#a8009a","#a90099","#aa0099","#ab0099","#ad0099","#ae0198","#af0198","#b00198","#b00198","#b10197","#b20197","#b30196","#b40296","#b50295","#b60295","#b70395","#b80395","#b90495","#ba0495","#ba0494","#bb0593","#bc0593","#bd0593","#be0692","#bf0692","#bf0692","#c00791","#c00791","#c10890","#c10990","#c20a8f","#c30a8e","#c30b8e","#c40c8d","#c50c8c","#c60d8b","#c60e8a","#c70f89","#c81088","#c91187","#ca1286","#ca1385","#cb1385","#cb1484","#cc1582","#cd1681","#ce1780","#ce187e","#cf187c","#cf197b","#d01a79","#d11b78","#d11c76","#d21c75","#d21d74","#d31e72","#d32071","#d4216f","#d4226e","#d5236b","#d52469","#d62567","#d72665","#d82764","#d82862","#d92a60","#da2b5e","#da2c5c","#db2e5a","#db2f57","#dc2f54","#dd3051","#dd314e","#de324a","#de3347","#df3444","#df3541","#df363d","#e0373a","#e03837","#e03933","#e13a30","#e23b2d","#e23c2a","#e33d26","#e33e23","#e43f20","#e4411d","#e4421c","#e5431b","#e54419","#e54518","#e64616","#e74715","#e74814","#e74913","#e84a12","#e84c10","#e84c0f","#e94d0e","#e94d0d","#ea4e0c","#ea4f0c","#eb500b","#eb510a","#eb520a","#eb5309","#ec5409","#ec5608","#ec5708","#ec5808","#ed5907","#ed5a07","#ed5b06","#ee5c06","#ee5c05","#ee5d05","#ee5e05","#ef5f04","#ef6004","#ef6104","#ef6204","#f06303","#f06403","#f06503","#f16603","#f16603","#f16703","#f16803","#f16902","#f16a02","#f16b02","#f16b02","#f26c01","#f26d01","#f26e01","#f36f01","#f37001","#f37101","#f37201","#f47300","#f47400","#f47500","#f47600","#f47700","#f47800","#f47a00","#f57b00","#f57c00","#f57e00","#f57f00","#f68000","#f68100","#f68200","#f78300","#f78400","#f78500","#f78600","#f88700","#f88800","#f88800","#f88900","#f88a00","#f88b00","#f88c00","#f98d00","#f98d00","#f98e00","#f98f00","#f99000","#f99100","#f99200","#f99300","#fa9400","#fa9500","#fa9600","#fb9800","#fb9900","#fb9a00","#fb9c00","#fc9d00","#fc9f00","#fca000","#fca100","#fda200","#fda300","#fda400","#fda600","#fda700","#fda800","#fdaa00","#fdab00","#fdac00","#fdad00","#fdae00","#feaf00","#feb000","#feb100","#feb200","#feb300","#feb400","#feb500","#feb600","#feb800","#feb900","#feb900","#feba00","#febb00","#febc00","#febd00","#febe00","#fec000","#fec100","#fec200","#fec300","#fec400","#fec500","#fec600","#fec700","#fec800","#fec901","#feca01","#feca01","#fecb01","#fecc02","#fecd02","#fece03","#fecf04","#fecf04","#fed005","#fed106","#fed308","#fed409","#fed50a","#fed60a","#fed70b","#fed80c","#fed90d","#ffda0e","#ffda0e","#ffdb10","#ffdc12","#ffdc14","#ffdd16","#ffde19","#ffde1b","#ffdf1e","#ffe020","#ffe122","#ffe224","#ffe226","#ffe328","#ffe42b","#ffe42e","#ffe531","#ffe635","#ffe638","#ffe73c","#ffe83f","#ffe943","#ffea46","#ffeb49","#ffeb4d","#ffec50","#ffed54","#ffee57","#ffee5b","#ffee5f","#ffef63","#ffef67","#fff06a","#fff06e","#fff172","#fff177","#fff17b","#fff280","#fff285","#fff28a","#fff38e","#fff492","#fff496","#fff49a","#fff59e","#fff5a2","#fff5a6","#fff6aa","#fff6af","#fff7b3","#fff7b6","#fff8ba","#fff8bd","#fff8c1","#fff8c4","#fff9c7","#fff9ca","#fff9cd","#fffad1","#fffad4","#fffbd8","#fffcdb","#fffcdf","#fffde2","#fffde5","#fffde8","#fffeeb","#fffeee","#fffef1","#fffef4"];
    const ironPaletteRGB = ironPaletteHex.map(c => hexToRGB(c));

    const glowPaletteHex = ["#060101","#080101","#0A0102","#0C0202","#0D0203","#0F0203","#110203","#130204","#150204","#170204","#180305","#1A0305","#1C0305","#1E0306","#200406","#220407","#230407","#250407","#270508","#290508","#2B0508","#2D0509","#2F0509","#310509","#330509","#35060A","#37060A","#39060A","#3B070B","#3C070C","#3E070C","#40070C","#42080D","#43080D","#45080D","#47080D","#49080E","#4B080E","#4D080E","#4F090F","#510910","#530910","#550910","#580A11","#5B0A11","#5E0A11","#610B12","#640B13","#670C14","#690C14","#6A0C15","#6C0C15","#6E0C15","#700C15","#710D16","#730D16","#750D16","#770D16","#790E17","#7B0E17","#7D0E18","#7F0F18","#810F19","#830F19","#850F19","#870F1A","#880F1A","#8A0F1A","#8C0F1A","#8E101B","#90101B","#92101C","#93111C","#95111D","#97111D","#99111D","#9B121E","#9D121E","#9F121E","#A0121E","#A2121F","#A4121F","#A61220","#A81320","#AA1321","#AC1321","#AE1321","#B01422","#B21422","#B41422","#B61523","#B71523","#B91523","#BB1523","#BD1524","#BE1524","#C01524","#C21525","#C41625","#C61626","#C81626","#CA1727","#CC1727","#CD1727","#CE1827","#CE1826","#CF1926","#CF1A26","#CF1A25","#D01B25","#D01C24","#D11D24","#D11D23","#D21E23","#D21E23","#D31F23","#D31F22","#D42022","#D42122","#D42121","#D52221","#D52320","#D62420","#D6241F","#D7251F","#D7251F","#D8261F","#D8261E","#D9271E","#D9271E","#D9281E","#DA281D","#DA291D","#DB2A1C","#DB2B1C","#DC2C1B","#DC2C1B","#DD2D1B","#DD2D1A","#DE2E1A","#DE2E1A","#DE2F1A","#DF3019","#DF3019","#E03118","#E03218","#E13317","#E13317","#E23417","#E23416","#E33516","#E33516","#E43615","#E43715","#E43715","#E53815","#E53914","#E63A14","#E63A14","#E73B13","#E73B13","#E83C12","#E83D12","#E93D11","#E93E11","#E93E11","#EA3F11","#EA3F10","#EB4010","#EB4110","#EC410F","#EC420F","#ED430E","#ED440E","#EE440D","#EE450D","#EE450D","#EF460D","#EF460C","#F0470C","#F0480C","#F1480B","#F1490B","#F24A0A","#F24B0A","#F34B09","#F34C09","#F34C09","#F44D09","#F44D08","#F54E08","#F54E08","#F64F08","#F75007","#F75007","#F75106","#F85206","#F85305","#F85305","#F95405","#F95404","#FA5504","#FA5504","#FB5604","#FC5703","#FC5703","#FC5802","#FD5902","#FD5A01","#FD5A01","#FE5B01","#FE5B00","#FF5C00","#FF5D00","#FF5E00","#FF5F00","#FF6000","#FF6100","#FF6200","#FF6400","#FF6500","#FF6600","#FF6700","#FF6900","#FF6A00","#FF6B00","#FF6C00","#FF6D00","#FF6E00","#FF6F00","#FF7100","#FF7200","#FF7300","#FF7400","#FF7500","#FF7600","#FF7700","#FF7800","#FF7900","#FF7B00","#FF7C00","#FF7E00","#FF7F00","#FF8000","#FF8100","#FF8200","#FF8300","#FF8400","#FF8500","#FF8600","#FF8800","#FF8900","#FF8A00","#FF8B00","#FF8C00","#FF8D00","#FF8E00","#FF8F00","#FF9100","#FF9200","#FF9300","#FF9500","#FF9600","#FF9700","#FF9800","#FF9900","#FF9A00","#FF9B00","#FF9C00","#FF9D00","#FF9E00","#FFA000","#FFA100","#FFA200","#FFA300","#FFA400","#FFA600","#FFA700","#FFA800","#FFA900","#FFAA00","#FFAC00","#FFAD00","#FFAE00","#FFAF00","#FFB000","#FFB100","#FFB200","#FFB300","#FFB400","#FFB500","#FFB600","#FFB800","#FFB900","#FFBA00","#FFBC00","#FFBD00","#FFBE00","#FFBF00","#FFC000","#FFC100","#FFC200","#FFC400","#FFC500","#FFC600","#FFC700","#FFC800","#FFC900","#FFCA00","#FFCB00","#FFCC00","#FFCE00","#FFCF00","#FFD000","#FFD200","#FFD300","#FFD400","#FFD500","#FFD600","#FFD700","#FFD800","#FFD900","#FFDA01","#FFDA03","#FFDB05","#FFDB08","#FFDB0A","#FFDB0C","#FFDC0F","#FFDC11","#FFDD14","#FFDD16","#FFDE18","#FFDE1A","#FFDE1D","#FFDF1F","#FFDF22","#FFDF24","#FFE026","#FFE028","#FFE02B","#FFE02D","#FFE12F","#FFE132","#FFE134","#FFE237","#FFE239","#FFE33C","#FFE33E","#FFE440","#FFE442","#FFE445","#FFE447","#FFE549","#FFE54B","#FFE54E","#FFE550","#FFE652","#FFE655","#FFE757","#FFE75A","#FFE85C","#FFE85F","#FFE861","#FFE963","#FFE965","#FFE968","#FFE96A","#FFEA6D","#FFEA6F","#FFEA71","#FFEB73","#FFEB76","#FFEB78","#FFEC7A","#FFEC7D","#FFED7F","#FFED82","#FFED84","#FFEE86","#FFEE88","#FFEE8A","#FFEF8D","#FFEF8F","#FFEF91","#FFEF94","#FFF096","#FFF099","#FFF09B","#FFF09D","#FFF19F","#FFF1A1","#FFF2A4","#FFF2A6","#FFF3A9","#FFF3AB","#FFF3AE","#FFF4B0","#FFF4B3","#FFF4B5","#FFF5B7","#FFF5B9","#FFF5BB","#FFF5BE","#FFF6C0","#FFF6C2","#FFF6C4","#FFF7C7","#FFF7C9","#FFF8CC","#FFF8CE","#FFF9D1","#FFF9D3","#FFF9D6","#FFF9D8","#FFFADA","#FFFADC","#FFFADF","#FFFAE1","#FFFBE4","#FFFBE6","#FFFCE8","#FFFCEA","#FFFDED","#FFFDEF","#FFFDF1","#FFFEF4","#FFFEF6","#FFFEF9","#FFFEFB","#FFFFFD"];
    const glowPaletteRGB = glowPaletteHex.map(c => hexToRGB(c));

    const yellowPaletteHex = ["#350300","#350300","#350400","#340400","#340500","#340600","#340600","#330700","#330800","#330900","#330900","#330A00","#330A00","#330B00","#330B00","#330C00","#330C00","#330D00","#320E00","#320E00","#320F00","#320F00","#321000","#321000","#321100","#321100","#321200","#321200","#321300","#321400","#321400","#321500","#331500","#331600","#331600","#331700","#331800","#331900","#331900","#341A00","#341B00","#341B00","#341C00","#341C00","#341D00","#341D00","#341E00","#351E00","#351F00","#352000","#362000","#362100","#362100","#362200","#372200","#372300","#372300","#372400","#382400","#382500","#382600","#392700","#392700","#392800","#3A2900","#3A2900","#3B2A00","#3B2A00","#3B2B00","#3C2B00","#3C2C00","#3D2D00","#3D2D00","#3E2E00","#3E2E00","#3F2F00","#3F2F00","#403000","#403000","#403100","#413200","#413200","#423300","#423300","#433400","#433400","#443500","#453500","#463600","#473700","#483800","#483800","#493900","#4A3A00","#4A3A00","#4B3B00","#4B3B00","#4C3C00","#4D3C00","#4E3D00","#4E3D00","#4F3E00","#503F00","#503F00","#514000","#524000","#534100","#544100","#544200","#554200","#564300","#574400","#584400","#584500","#594500","#5A4600","#5C4700","#5D4800","#5E4800","#5E4900","#5F4900","#604A00","#614B00","#624B00","#624C00","#634C00","#654D00","#664D00","#674E00","#684E00","#684F00","#694F00","#6A5000","#6B5100","#6C5100","#6D5200","#6E5200","#6F5300","#705300","#725400","#735400","#735500","#745600","#755600","#765700","#775800","#785900","#7A5900","#7B5A00","#7C5A00","#7D5B00","#7E5B00","#7F5C00","#805D00","#815D00","#825E00","#835E00","#855F00","#865F00","#876000","#886000","#896100","#8A6200","#8B6200","#8C6300","#8D6300","#8E6400","#8F6400","#916500","#926600","#936600","#946700","#956800","#966900","#976900","#986A00","#996A00","#9B6B00","#9C6B00","#9E6C00","#9F6C00","#A06D00","#A16D00","#A26E00","#A36F00","#A46F00","#A47000","#A57000","#A77100","#A87100","#A97200","#AA7200","#AB7300","#AD7400","#AE7400","#AF7500","#B07500","#B17600","#B27600","#B37700","#B47800","#B57900","#B67900","#B77A00","#B87B00","#B97B00","#BA7C00","#BB7C00","#BC7D00","#BE7D00","#BF7E00","#C07E00","#C17F00","#C27F00","#C38000","#C38100","#C48100","#C58200","#C68200","#C88300","#C98300","#CA8400","#CB8400","#CC8500","#CD8600","#CE8700","#CE8700","#CF8800","#D08900","#D18900","#D28A00","#D38A00","#D48B00","#D58B00","#D68C00","#D78D00","#D88D00","#D88E00","#D98E00","#DA8F00","#DB8F00","#DC9000","#DD9000","#DD9100","#DE9100","#DF9200","#E09300","#E09300","#E19400","#E19400","#E29500","#E39500","#E49600","#E59700","#E59700","#E69800","#E79900","#E89A00","#E89A00","#E99B00","#E99B00","#EA9C00","#EB9C00","#EC9D00","#EC9D00","#ED9E00","#EE9F00","#EE9F00","#EFA000","#EFA000","#F0A100","#F0A100","#F0A200","#F1A200","#F1A300","#F1A300","#F2A400","#F3A500","#F3A500","#F4A600","#F4A700","#F5A800","#F5A800","#F6A900","#F6A900","#F7AA00","#F7AB00","#F8AB00","#F8AC00","#F8AC00","#F8AD00","#F9AD00","#F9AE00","#F9AE00","#F9AF00","#FAAF00","#FAB000","#FAB100","#FBB100","#FBB200","#FBB200","#FBB300","#FCB300","#FCB400","#FCB400","#FCB500","#FCB500","#FCB600","#FCB700","#FDB800","#FDB800","#FDB900","#FDBA00","#FDBA00","#FDBB00","#FDBB00","#FDBC00","#FEBD00","#FEBD00","#FEBE00","#FEBE00","#FEBF00","#FEBF00","#FEC000","#FEC000","#FEC100","#FEC100","#FEC200","#FEC300","#FEC300","#FEC400","#FEC400","#FEC500","#FEC500","#FEC600","#FDC700","#FDC800","#FDC800","#FDC900","#FDCA00","#FDCA00","#FDCB00","#FCCB00","#FCCC00","#FCCC00","#FCCD00","#FCCD00","#FCCE00","#FCCF00","#FBCF00","#FBD000","#FBD000","#FBD100","#FAD100","#FAD200","#FAD200","#FAD300","#FAD300","#FAD400","#FAD500","#F9D500","#F9D600","#F9D600","#F9D700","#F8D800","#F8D900","#F8D900","#F8DA00","#F7DA00","#F7DB00","#F7DC00","#F6DC00","#F6DD00","#F6DD00","#F6DE00","#F5DE00","#F5DF00","#F5DF00","#F5E000","#F4E100","#F4E100","#F4E200","#F3E200","#F3E300","#F3E300","#F2E400","#F2E400","#F1E500","#F1E600","#F1E600","#F0E700","#F0E800","#F0E900","#EFE900","#EFEA00","#EFEA00","#EFEB00","#EEEB00","#EEEC00","#EEEC00","#EDED00","#EDEE00","#EDEE00","#EDEF00","#ECEF00","#ECF000","#ECF000","#EBF100","#EBF100","#EAF200","#EAF300","#E9F300","#E9F400","#E9F400","#E9F500","#E8F500","#E8F600","#E8F700","#E8F700","#E7F800","#E7F900","#E7FA00","#E6FA00","#E6FB00","#E6FB00","#E6FC00","#E5FC00","#E5FD00","#E5FD00","#E5FE00","#E5FE00"];
    const yellowPaletteRGB = yellowPaletteHex.map(c => hexToRGB(c));

    const grayPaletteHex = ["#010101","#020202","#020202","#030303","#030303","#040404","#040404","#050505","#050505","#060606","#070707","#080808","#090909","#090909","#0A0A0A","#0A0A0A","#0B0B0B","#0B0B0B","#0C0C0C","#0D0D0D","#0D0D0D","#0E0E0E","#0E0E0E","#0F0F0F","#0F0F0F","#101010","#101010","#111111","#111111","#121212","#131313","#131313","#141414","#151515","#161616","#161616","#171717","#171717","#181818","#181818","#191919","#1A1A1A","#1A1A1A","#1B1B1B","#1B1B1B","#1C1C1C","#1C1C1C","#1D1D1D","#1D1D1D","#1E1E1E","#1F1F1F","#1F1F1F","#202020","#202020","#212121","#212121","#222222","#232323","#232323","#242424","#252525","#262626","#262626","#272727","#272727","#282828","#282828","#292929","#292929","#2A2A2A","#2A2A2A","#2B2B2B","#2C2C2C","#2C2C2C","#2D2D2D","#2D2D2D","#2E2E2E","#2E2E2E","#2F2F2F","#2F2F2F","#303030","#313131","#313131","#323232","#333333","#343434","#343434","#353535","#353535","#363636","#363636","#373737","#383838","#383838","#393939","#393939","#3A3A3A","#3A3A3A","#3B3B3B","#3B3B3B","#3C3C3C","#3C3C3C","#3D3D3D","#3E3E3E","#3E3E3E","#3F3F3F","#404040","#414141","#414141","#424242","#424242","#434343","#444444","#444444","#454545","#454545","#464646","#464646","#474747","#474747","#484848","#484848","#494949","#4A4A4A","#4A4A4A","#4B4B4B","#4B4B4B","#4C4C4C","#4C4C4C","#4D4D4D","#4E4E4E","#4E4E4E","#4F4F4F","#505050","#515151","#515151","#525252","#525252","#535353","#535353","#545454","#545454","#555555","#565656","#565656","#575757","#575757","#585858","#585858","#595959","#595959","#5A5A5A","#5B5B5B","#5C5C5C","#5C5C5C","#5D5D5D","#5E5E5E","#5E5E5E","#5F5F5F","#5F5F5F","#606060","#606060","#616161","#626262","#626262","#636363","#636363","#646464","#646464","#656565","#656565","#666666","#666666","#676767","#686868","#686868","#696969","#696969","#6A6A6A","#6B6B6B","#6C6C6C","#6C6C6C","#6D6D6D","#6D6D6D","#6E6E6E","#6F6F6F","#6F6F6F","#707070","#707070","#717171","#717171","#727272","#727272","#737373","#747474","#747474","#757575","#757575","#767676","#767676","#777777","#777777","#787878","#797979","#797979","#7A7A7A","#7B7B7B","#7C7C7C","#7C7C7C","#7D7D7D","#7D7D7D","#7E7E7E","#7E7E7E","#7F7F7F","#7F7F7F","#808080","#818181","#818181","#828282","#828282","#838383","#838383","#848484","#848484","#858585","#868686","#878787","#878787","#888888","#898989","#898989","#8A8A8A","#8A8A8A","#8B8B8B","#8B8B8B","#8C8C8C","#8D8D8D","#8D8D8D","#8E8E8E","#8E8E8E","#8F8F8F","#8F8F8F","#909090","#909090","#919191","#919191","#929292","#939393","#939393","#949494","#949494","#959595","#969696","#979797","#979797","#989898","#999999","#999999","#9A9A9A","#9A9A9A","#9B9B9B","#9B9B9B","#9C9C9C","#9C9C9C","#9D9D9D","#9D9D9D","#9E9E9E","#9F9F9F","#9F9F9F","#A0A0A0","#A0A0A0","#A1A1A1","#A1A1A1","#A2A2A2","#A2A2A2","#A3A3A3","#A4A4A4","#A5A5A5","#A5A5A5","#A6A6A6","#A7A7A7","#A7A7A7","#A8A8A8","#A8A8A8","#A9A9A9","#A9A9A9","#AAAAAA","#ABABAB","#ABABAB","#ACACAC","#ACACAC","#ADADAD","#ADADAD","#AEAEAE","#AEAEAE","#AFAFAF","#AFAFAF","#B0B0B0","#B1B1B1","#B2B2B2","#B2B2B2","#B3B3B3","#B4B4B4","#B4B4B4","#B5B5B5","#B5B5B5","#B6B6B6","#B6B6B6","#B7B7B7","#B8B8B8","#B8B8B8","#B9B9B9","#B9B9B9","#BABABA","#BABABA","#BBBBBB","#BBBBBB","#BCBCBC","#BDBDBD","#BDBDBD","#BEBEBE","#BEBEBE","#BFBFBF","#BFBFBF","#C0C0C0","#C1C1C1","#C2C2C2","#C2C2C2","#C3C3C3","#C4C4C4","#C4C4C4","#C5C5C5","#C5C5C5","#C6C6C6","#C6C6C6","#C7C7C7","#C7C7C7","#C8C8C8","#C8C8C8","#C9C9C9","#CACACA","#CACACA","#CBCBCB","#CBCBCB","#CCCCCC","#CCCCCC","#CDCDCD","#CECECE","#CFCFCF","#D0D0D0","#D0D0D0","#D1D1D1","#D1D1D1","#D2D2D2","#D2D2D2","#D3D3D3","#D3D3D3","#D4D4D4","#D4D4D4","#D5D5D5","#D6D6D6","#D6D6D6","#D7D7D7","#D7D7D7","#D8D8D8","#D8D8D8","#D9D9D9","#D9D9D9","#DADADA","#DADADA","#DBDBDB","#DCDCDC","#DDDDDD","#DDDDDD","#DEDEDE","#DFDFDF","#DFDFDF","#E0E0E0","#E0E0E0","#E1E1E1","#E2E2E2","#E2E2E2","#E3E3E3","#E3E3E3","#E4E4E4","#E4E4E4","#E5E5E5","#E5E5E5","#E6E6E6","#E6E6E6","#E7E7E7","#E8E8E8","#E8E8E8","#E9E9E9","#E9E9E9","#EAEAEA","#EAEAEA","#EBEBEB","#ECECEC","#EDEDED","#EDEDED","#EEEEEE","#EFEFEF","#EFEFEF","#F0F0F0","#F0F0F0","#F1F1F1","#F1F1F1","#F2F2F2","#F2F2F2","#F3F3F3","#F4F4F4","#F4F4F4","#F5F5F5","#F5F5F5","#F6F6F6","#F6F6F6","#F7F7F7","#F8F8F8","#F8F8F8","#F9F9F9","#FAFAFA","#FBFBFB","#FBFBFB","#FCFCFC","#FCFCFC","#FDFDFD","#FDFDFD","#FEFEFE","#FEFEFE","#FEFEFE","#FFFFFF"];
    const grayPaletteRGB = grayPaletteHex.map(c => hexToRGB(c));

    const limePaletteHex = ["#0500AC","#0602AC","#0602AC","#0605AC","#0708AD","#0708AD","#070BAD","#070EAD","#0810AE","#0810AE","#0812AE","#0914AE","#0914AE","#0916AF","#0A18AF","#0A1AAF","#0A1AAF","#0A1CB0","#0B1DB0","#0B1DB0","#0B1FB0","#0B20B1","#0C22B1","#0C22B1","#0C23B1","#0C25B1","#0C25B1","#0C26B2","#0C28B2","#0D29B2","#0D29B2","#0D2AB3","#0D2CB3","#0D2CB3","#0D2DB3","#0D2EB3","#0E30B3","#0E30B3","#0E31B4","#0E32B4","#0E32B4","#0E34B4","#0E35B4","#0E36B4","#0E36B4","#0E37B4","#0E38B5","#0E38B5","#0E3AB5","#0E3BB5","#0E3CB5","#0E3CB5","#0E3DB5","#0E3EB5","#0E3EB5","#0E40B5","#0E41B5","#0D42B5","#0D42B5","#0D43B5","#0D44B5","#0D44B5","#0D46B5","#0D47B5","#0C48B5","#0C48B5","#0C49B5","#0C4AB5","#0C4AB5","#0C4BB5","#0B4DB4","#0B4EB4","#0B4EB4","#0B4FB4","#0B50B4","#0B50B4","#0A51B3","#0A53B3","#0A54B3","#0A54B3","#0955B2","#0956B2","#0956B2","#0857B1","#0858B0","#085AB0","#085AB0","#075CAE","#065EAE","#065FAD","#0660AC","#0660AC","#0661AA","#0662A9","#0764A8","#0764A8","#0865A7","#0A66A5","#0A66A5","#0B67A4","#0D69A2","#0F6AA1","#0F6AA1","#116BA0","#136C9E","#136C9E","#146D9D","#166E9B","#186F99","#186F99","#1A7097","#1B7296","#1B7296","#1D7394","#1E7492","#1F7591","#1F7591","#21768F","#22778D","#22778D","#23788B","#247989","#257A87","#257A87","#277C85","#287D83","#287D83","#287E81","#297F7F","#2A807D","#2A807D","#2B817B","#2C8279","#2C8279","#2C8377","#2D8475","#2E8572","#2E8572","#2E8670","#2E876E","#2E876E","#2F896C","#2F8A69","#308B67","#308B67","#308C64","#308D62","#308D62","#308E60","#308F5D","#31905B","#31905B","#319159","#319256","#319256","#329354","#329452","#339550","#339550","#34964E","#34974C","#34974C","#35984A","#369948","#379A47","#379A47","#389B45","#399C43","#399C43","#3A9D41","#3B9E40","#3C9E3E","#3C9E3E","#3D9F3C","#3EA03B","#3EA03B","#40A139","#41A238","#42A336","#42A336","#44A334","#45A433","#45A433","#47A531","#48A630","#4AA72E","#4AA72E","#4BA82D","#4DA92C","#4DA92C","#4FA92A","#51AA29","#52AB27","#52AB27","#54AC26","#56AC24","#56AC24","#57AD23","#5AAE22","#5BAF20","#5BAF20","#5DAF1F","#5FB01E","#5FB01E","#61B11C","#63B11B","#65B21A","#65B21A","#67B318","#69B417","#69B417","#6BB415","#6DB514","#6FB613","#6FB613","#71B712","#73B710","#73B710","#75B80F","#77B80E","#79B90C","#79B90C","#7BBA0B","#7DBA0A","#7DBA0A","#80BB08","#82BC07","#84BC06","#84BC06","#86BD06","#88BD05","#88BD05","#8ABE04","#8DBF04","#8FBF03","#8FBF03","#91C003","#93C103","#93C103","#95C103","#97C203","#9AC202","#9AC202","#9CC302","#9EC303","#9EC303","#A0C403","#A2C403","#A4C503","#A4C503","#A7C603","#A9C603","#A9C603","#ABC704","#ADC704","#AFC804","#AFC804","#B1C805","#B3C905","#B3C905","#B5C906","#B7CA06","#B9CB07","#B9CB07","#BDCC09","#BFCD0A","#C1CD0B","#C3CE0B","#C3CE0B","#C4CE0C","#C6CF0E","#C8CF0F","#C8CF0F","#CAD010","#CCD111","#CCD111","#CED112","#CFD213","#D1D214","#D1D214","#D3D315","#D4D417","#D4D417","#D6D418","#D8D519","#DAD51A","#DAD51A","#DBD61C","#DDD71D","#DDD71D","#DED71E","#E0D820","#E1D921","#E1D921","#E3DA22","#E4DA24","#E4DA24","#E6DB25","#E7DC27","#E9DC28","#E9DC28","#EADD2A","#EBDE2C","#EBDE2C","#ECDF2D","#EEDF2F","#EFE031","#EFE031","#F0E132","#F1E235","#F1E235","#F2E236","#F3E338","#F4E43B","#F4E43B","#F4E53D","#F5E63F","#F5E63F","#F5E742","#F6E845","#F7E948","#F7E948","#F7EA4B","#F8EB4F","#F8EB4F","#F8EC53","#F9ED58","#FAED5D","#FAED5D","#FAEE62","#FBEF67","#FBEF67","#FCF06D","#FCF073","#FDF179","#FDF179","#FDF280","#FEF387","#FEF387","#FEF48E","#FFF496","#FFF59F","#FFF59F","#FFF5A8","#FFF6B1","#FFF6B1","#FFF7BB","#FEF7C6","#FEF8D2","#FEF8D2","#FDF8DE","#FBF9EB","#FBF9EB"];
    const limePaletteRGB = limePaletteHex.map(c => hexToRGB(c));

    
    function hexToRGB(hex) {
        var r = parseInt(hex.slice(1, 3), 16),
            g = parseInt(hex.slice(3, 5), 16),
            b = parseInt(hex.slice(5, 7), 16);
        
            return [r, g, b];
    }

    function renderSpectrumImage() {
        if (!waterfallState.previewEnabled) {
            return;
        }

        const range = waterfallState.spectrumRange;
        if (!range || range.length !== 2) {
            alert('Error: invalid from or to spectrum index.');
            return;
        }
        
        const canvas = document.getElementById('preview-plot');
        canvas.width = waterfallData.baseSpectrum.channelCount;
        canvas.height = constants.previewHeight;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        ctx.fillStyle = '#444';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const combinedSpectrum = exports.combineSpectrums(
            waterfallData.deltas,
            Math.floor(range[0] / waterfallState.spectrumBinning),
            Math.floor(range[1] / waterfallState.spectrumBinning),
            waterfallData.baseSpectrum, 
            'preview',
        );

        const cpsInChannel = [];
        let maxCps = 0;
        combinedSpectrum.channels.forEach((channelValue, channelIndex) => {
            let cps = channelValue / combinedSpectrum.duration;
            // TODO: duplicated code
            if (waterfallState.subtractBase) {
                const baseCps = waterfallData.baseSpectrum.channels[channelIndex] / waterfallData.baseSpectrum.duration;
                cps -= baseCps;
                if (cps < 0) {
                    cps = 0;
                }
            }

            cpsInChannel.push(cps);

            if (cps > maxCps) {
                maxCps = cps;
            }
        });

        // spectrum render
        const spectrumHeight = canvas.height;// - constants.channelAxisHeight;
        const imageData = ctx.getImageData(0, 0, waterfallData.baseSpectrum.channelCount, spectrumHeight);
        const lineColor = hexToRGB('#ABABAB');
        cpsInChannel.forEach((cps, channelIndex) => {
            const counts = Math.round(cps * combinedSpectrum.duration);
            const maxCounts = Math.round(maxCps * combinedSpectrum.duration);
            let barHeight = Math.floor((counts / maxCounts) * spectrumHeight);
            switch (waterfallState.scale) {
                case 'log':
                    barHeight = Math.floor((Math.log(counts + 1) / Math.log(maxCounts + 1)) * spectrumHeight);
                    break;
                case 'sqrt':
                    barHeight = Math.floor((Math.sqrt(counts) / Math.sqrt(maxCounts + 1)) * spectrumHeight);
                    break;
            }

            const fillColor = getPointColor(cps, maxCps);
            for (let y = spectrumHeight - barHeight; y <= spectrumHeight; y++) {
                const color = y === spectrumHeight - barHeight
                    ? lineColor
                    : fillColor;
                const pxOffset = (y * waterfallData.baseSpectrum.channelCount + channelIndex) * 4;
                imageData.data[pxOffset + 0] = color[0];
                imageData.data[pxOffset + 1] = color[1];
                imageData.data[pxOffset + 2] = color[2];
                imageData.data[pxOffset + 3] = 255;
            }
        });
        
        ctx.putImageData(imageData, 0, 0);
    }

    function renderWaterfallImage() {
        const canvas = document.getElementById('waterfall-plot');
        canvas.width = waterfallData.baseSpectrum.channelCount + constants.timeAxisWidth;
        canvas.height = waterfallData.deltas.length + constants.channelAxisHeight;

        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        ctx.fillStyle = constants.backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        let maxCps = 0;
        waterfallData.deltas.forEach((delta, deltaIndex) => {
            delta.channels.forEach((channelValue, channelIndex) => {
                if (!channelValue) {
                    return;
                }

                let cps = channelValue / delta.duration;
                // TODO: duplicated code
                if (waterfallState.subtractBase) {
                    const baseCps = waterfallData.baseSpectrum.channels[channelIndex] / waterfallData.baseSpectrum.duration;
                    cps -= baseCps;
                    if (cps < 0) {
                        cps = 0;
                    }
                }

                maxCps = Math.max(maxCps, cps);
            });
        });

        // waterfall render
        const imageData = ctx.getImageData(constants.timeAxisWidth, 0, waterfallData.baseSpectrum.channelCount, waterfallData.deltas.length);
        waterfallData.deltas.forEach((delta, deltaIndex) => {
            delta.channels.forEach((channelValue, channelIndex) => {
                if (!channelValue) {
                    return;
                }

                let cps = channelValue / delta.duration;
                // TODO: duplicated code
                if (waterfallState.subtractBase) {
                    const baseCps = waterfallData.baseSpectrum.channels[channelIndex] / waterfallData.baseSpectrum.duration;
                    cps -= baseCps;
                    if (cps < 0) {
                        cps = 0;
                    }
                }

                const rgbColor = getPointColor(cps, maxCps);
                const pxOffset = (deltaIndex * waterfallData.baseSpectrum.channelCount + channelIndex) * 4;
                imageData.data[pxOffset + 0] = rgbColor[0];
                imageData.data[pxOffset + 1] = rgbColor[1];
                imageData.data[pxOffset + 2] = rgbColor[2];
                imageData.data[pxOffset + 3] = 255;
            });
        });
        ctx.putImageData(imageData, constants.timeAxisWidth, 0);

        if (waterfallState.blur) {
            const blurData = ctx.createImageData(imageData.width, imageData.height);
            const radius = constants.blurRadius;
            for (let x = 0; x < imageData.width; x++) {
                for (let y = 0; y <= imageData.height; y++) {
                    let r = 0;
                    let g = 0;
                    let b = 0;
                    for (let ky = -radius; ky <= radius; ++ky) {
                        for (let kx = -radius; kx <= radius; ++kx) {
                            const sourcePxOffset = ((y + ky) * imageData.width + (x + kx)) * 4;
                            if (sourcePxOffset < 0 || sourcePxOffset > imageData.data.length - 1) {
                                continue;
                            }

                            r += imageData.data[sourcePxOffset + 0];
                            g += imageData.data[sourcePxOffset + 1];
                            b += imageData.data[sourcePxOffset + 2];
                        }
                    }
                    
                    const destPxOffset = (y * blurData.width + x) * 4;
                    const coeff = Math.pow(radius + 1, 2) * 2.1;
                    blurData.data[destPxOffset + 0] = r / coeff;
                    blurData.data[destPxOffset + 1] = g / coeff;
                    blurData.data[destPxOffset + 2] = b / coeff;
                    blurData.data[destPxOffset + 3] = 255;
                }
            }

            ctx.putImageData(blurData, constants.timeAxisWidth, 0);
        }

        // time axis
        const timestamps = waterfallData.deltas.map(d => d.timestamp);
        for (let tsIndex = 0; tsIndex < timestamps.length; tsIndex += constants.timestampHeight) {
            const timestamp = timestamps[tsIndex];
            ctx.textBaseline = 'top';
            ctx.fillStyle = constants.textColor;
            let label = common.timeToString(timestamp);
            label += ': ' + tsIndex * waterfallState.spectrumBinning * originalWaterfallData.spectrumBinning;
            ctx.fillText(label, 0, tsIndex);

            // label tick
            const tickWidth = tsIndex % 100 === 0
                ? constants.timestampTickWidth
                : constants.timestampTickWidth / 2;
            for (let x = constants.timeAxisWidth - tickWidth; x < constants.timeAxisWidth; x++) {
                ctx.fillRect(x, tsIndex, 1, 1);
            }
        }

        // display selection
        if (waterfallState.previewEnabled && waterfallState.spectrumRange && waterfallState.spectrumRange.length === 2) {
            const fromY = Math.floor(waterfallState.spectrumRange[0] / waterfallState.spectrumBinning);
            const toY = Math.floor(waterfallState.spectrumRange[1] / waterfallState.spectrumBinning);
            for (let y = fromY; y <= toY; y++) {
                ctx.fillRect(constants.timeAxisWidth - 2, y, 2, 1);
            }
        }

        renderEnergyAxis(canvas, ctx, waterfallData.deltas.length);
    }

    function getPointColor(cps, maxCps) {
        const lowerCpsBound = maxCps * waterfallState.minCpsPercent / 100;
        const upperCpsBound = maxCps * waterfallState.maxCpsPercent / 100;
        cps -= lowerCpsBound;
        if (cps < 0) {
            cps = 0;
        }

        const ratio = cps / (upperCpsBound - lowerCpsBound);

        let palette;
        switch (waterfallState.palette) {
            case 'lime':
                palette = limePaletteRGB.slice(10);
                break;
            case 'glow':
                palette = glowPaletteRGB.slice(10);
                break;
            case 'yellow':
                palette = yellowPaletteRGB;
                break;
            case 'gray':
                palette = grayPaletteRGB.slice(30);
                break;
            case 'iron':
            default:
                palette = ironPaletteRGB.slice(5);
                break;
        }

        let colorIndex = Math.round(ratio * (palette.length - 1));
        switch (waterfallState.scale) {
            case 'log':
                colorIndex = Math.round((Math.log(colorIndex + 1) / Math.log(palette.length)) * (palette.length - 1));
                break;
            case 'sqrt':
                colorIndex = Math.round((Math.sqrt(colorIndex) / Math.sqrt(palette.length)) * (palette.length - 1));
                break;
            default:
                break;
        }

        return palette[colorIndex] || palette[palette.length - 1];
    }

    function renderEnergyAxis(canvas, ctx, baseline) {
        // calculate energy for each channel
        const allEnergies = [];
        for (let i = 0; i < waterfallData.baseSpectrum.channelCount; i++) {
            const energy = common.channelToEnergy(i);
            allEnergies.push(energy);
        }
    
        // calculate channels for 0, 100, 200, 300... enegries 
        const renderEnergies = {};
        for (let energy = 0, channel = 0; energy < allEnergies[allEnergies.length - 1]; energy += 100) {
            while (allEnergies[channel] < energy) {
                channel++;
            }
            renderEnergies[channel] = energy;
        }
    
        // energy axis render
        const energyAxisBaseline = baseline;
        const channelAxisBaseline = baseline + constants.channelAxisHeight / 2;
        let kevRendered = false;
        for (let x = constants.timeAxisWidth; x < canvas.width; x++) {
            const channelNumber = x - constants.timeAxisWidth;
            const energy = renderEnergies[channelNumber];
    
            if (energy != undefined && energy % 500 === 0) {
                ctx.textBaseline = 'top';
                ctx.fillStyle = constants.textColor;
                const label = kevRendered ? energy.toString() : energy + ' keV';
                ctx.fillText(label, x, energyAxisBaseline + constants.channelAxisTickHeight);
                kevRendered = true;
            }
    
            if (energy != undefined && energy % 100 === 0) {
                const tickHeight = energy % 500 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
                for (let y = energyAxisBaseline; y < energyAxisBaseline + tickHeight; y++) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
    
            if (channelNumber % 100 === 0) {
                ctx.textBaseline = 'top';
                ctx.fillStyle = constants.textColor;
                const label = channelNumber === 0 ? channelNumber + ' channel' : channelNumber.toString();
                ctx.fillText(label, x, channelAxisBaseline + constants.channelAxisTickHeight);
            }
    
            if (channelNumber % 10 === 0) {
                const tickHeight = channelNumber % 50 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
                for (let y = channelAxisBaseline; y < channelAxisBaseline + tickHeight; y++) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    }
})();
</script>
		<script>(function(){
    // TODO: refactor: move state control to waterfall-control.js, keep only rendering here
    // cps plot render
    const fromChannelInput1 = document.getElementById('from-channel-1');
    const toChannelInput1 = document.getElementById('to-channel-1');
    const previewCheckbox = document.getElementById('preview-enabled');
    const fromChannelInput2 = document.getElementById('from-channel-2');
    const toChannelInput2 = document.getElementById('to-channel-2');
    const fromSpectrumInput = document.getElementById('from-spectrum');
    const toSpectrumInput = document.getElementById('to-spectrum');
    const compareCheckbox = document.getElementById('cps-comparison');
    const cpsToMapButton = document.getElementById('export-cps-map');
    const comparisonToMapButton = document.getElementById('export-comparison-map');
    const spgToSpectrumFileButton = document.getElementById('spg-range-to-file');
    const spgAsBaseButton = document.getElementById('spg-range-as-base');

    compareCheckbox.addEventListener('change', async () => await cps.renderCpsAsync());
    cpsToMapButton.addEventListener('click', () => exportCpsMap());
    comparisonToMapButton.addEventListener('click', () => exportComparisonMap());
    spgToSpectrumFileButton.addEventListener('click', () => exportSpectrumRange());
    spgAsBaseButton.addEventListener('click', () => spectrumRangeAsBase());
    previewCheckbox.addEventListener('change', async () => await previewEnabledChange());
    fromChannelInput1.addEventListener('change', async () => await onChannelIndexInputChange());
    toChannelInput1.addEventListener('change', async () => await onChannelIndexInputChange());
    fromChannelInput2.addEventListener('change', async () => await onChannelIndexInputChange());
    toChannelInput2.addEventListener('change', async () => await onChannelIndexInputChange());
    fromSpectrumInput.addEventListener('change', async () => await onSpectrumIndexInputChange());
    toSpectrumInput.addEventListener('change', async () => await onSpectrumIndexInputChange());
    
    window.cps = {
        initCpsControls: () => initCpsControls(),
        renderCps: () => renderCps(),
        renderCpsAsync: () => common.executeWithStatusAsync('Rendering cps...', () => renderCps()),
    }

    function initCpsControls() {
        waterfallState.channelRange1 = [0, waterfallData.baseSpectrum.channelCount - 1];
        waterfallState.channelRange2 = [0, waterfallData.baseSpectrum.channelCount - 1];
        waterfallState.spectrumRange = [0, waterfallData.deltas.length - 1];

        fromChannelInput1.value = waterfallState.channelRange1[0];
        toChannelInput1.value = waterfallState.channelRange1[1];
        fromChannelInput2.value = waterfallState.channelRange2[0];
        toChannelInput2.value = waterfallState.channelRange2[1];
        fromSpectrumInput.value = waterfallState.spectrumRange[0];
        toSpectrumInput.value = waterfallState.spectrumRange[1];
    }

    async function onChannelIndexInputChange() {
        waterfallState.channelRange1 = getChannelRange(fromChannelInput1, toChannelInput1);
        waterfallState.channelRange2 = getChannelRange(fromChannelInput2, toChannelInput2);

        await cps.renderCpsAsync();
    }

    function getChannelRange(fromInput, toInput) {
        let fromChannel = parseInt(fromInput.value);
        let toChannel = parseInt(toInput.value);

        if (isNaN(fromChannel) || fromChannel < 0) {
            fromChannel = 0;
            fromInput.value = 0;
        }

        if (fromChannel > waterfallData.baseSpectrum.channelCount - 1) {
            fromChannel = waterfallData.baseSpectrum.channelCount - 1;
            fromInput.value = waterfallData.baseSpectrum.channelCount - 1;
        }
        
        if (isNaN(toChannel) || toChannel > waterfallData.baseSpectrum.channelCount - 1) {
            toChannel = waterfallData.baseSpectrum.channelCount - 1;
            toInput.value = waterfallData.baseSpectrum.channelCount - 1;
        }

        if (fromChannel > toChannel) {
            toChannel = fromChannel;
            fromInput.value = fromChannel;
            toInput.value = toChannel;
        }

        return [fromChannel, toChannel];
    }

    async function onSpectrumIndexInputChange() {
        waterfallState.spectrumRange = getSpectrumRange();
        if (waterfallState.previewEnabled && waterfallState.spectrumRange && waterfallState.spectrumRange.length === 2) {
            await waterfall.renderSpectrumImageAsync();
            await waterfall.renderWaterfallImageAsync();
        }
    }

    function getSpectrumRange() {
        let fromSpectrum = parseInt(fromSpectrumInput.value);
        let toSpectrum = parseInt(toSpectrumInput.value);
        if (isNaN(fromSpectrum) || fromSpectrum < 0) {
            fromSpectrum = 0;
            fromSpectrumInput.value = 0;
        }

        if (fromSpectrum > originalWaterfallData.deltas.length - 1) {
            fromSpectrum = originalWaterfallData.deltas.length - 1;
            fromSpectrumInput.value = originalWaterfallData.deltas.length - 1;
        }
        
        if (isNaN(toSpectrum) || toSpectrum > originalWaterfallData.deltas.length - 1) {
            toSpectrum = originalWaterfallData.deltas.length - 1;
            toSpectrumInput.value = originalWaterfallData.deltas.length - 1;
        }

        if (fromSpectrum > toSpectrum) {
            toSpectrum = fromSpectrum;
            fromSpectrumInput.value = fromSpectrum;
            toSpectrumInput.value = toSpectrum;
        }

        return [fromSpectrum, toSpectrum];
    }

    async function previewEnabledChange() {
        if (previewCheckbox.checked) {
            waterfallControl.showPreview();
            if (waterfallState.spectrumRange && waterfallState.spectrumRange.length === 2) {
                await waterfall.renderSpectrumImageAsync();
                await waterfall.renderWaterfallImageAsync();
            }
        } else {
            waterfallControl.hidePreview();
        }
    }

    function getCountsInRange(from, to) {
        from = from < 0 ? 0 : from;
        to = to >= waterfallData.baseSpectrum.channelCount 
            ? waterfallData.baseSpectrum.channelCount - 1
            : to; 

        const countsInRange = {};
        waterfallData.deltas.forEach((delta, deltaIndex) => {
            for (let ci = from; ci <= to; ci++) {
                if (countsInRange[deltaIndex] === undefined) {
                    countsInRange[deltaIndex] = delta.channels[ci];
                } else {
                    countsInRange[deltaIndex] += delta.channels[ci];
                }

                if (waterfallState.subtractBase) {
                    countsInRange[deltaIndex] -= waterfallData.baseSpectrum.channels[ci] * (delta.duration / waterfallData.baseSpectrum.duration);
                }
            }

            if (countsInRange[deltaIndex] < 0) {
                countsInRange[deltaIndex] = 0;
            }
        });
        
        return countsInRange;
    }
    
    function countsToCps(countsInRange) {
        const cpsInRange = {};
        Object.keys(countsInRange).forEach(deltaIndex => {
            cpsInRange[deltaIndex] = countsInRange[deltaIndex] / waterfallData.deltas[deltaIndex].duration;
        });
        
        return cpsInRange;
    }
    
    function getRenderData(valuesInRange) {
        let max = 0;
        let min = Infinity;
        for (let i = 0; i < waterfallData.deltas.length; i++) {
            if (valuesInRange[i] === undefined) {
                continue;
            }

            max = Math.max(max, valuesInRange[i]);
            min = Math.min(min, valuesInRange[i]);
        }

        return {
            values: valuesInRange,
            max: max,
            min: min
        }
    }

    function renderCps() {
        const cpsCanvas = document.getElementById('cps-plot');
        cpsCanvas.width = waterfallData.deltas.length + constants.channelAxisHeight;
        cpsCanvas.height = constants.cpsPlotHeight;
    
        const range1 = waterfallState.channelRange1;
        if (!range1 || range1.length !== 2) {
            cpsToMapButton.disabled = true;
            comparisonToMapButton.disabled = true;
            renderCpsData(cpsCanvas);
            return;
        }
        
        const range2 = waterfallState.channelRange2;
        if (compareCheckbox.checked && (!range2 || range2.length !== 2)) {
            cpsToMapButton.disabled = true;
            comparisonToMapButton.disabled = true;
            renderCpsData(cpsCanvas);
            return;
        }

        if (compareCheckbox.checked) {
            comparisonToMapButton.disabled = false;
            cpsToMapButton.disabled = false;
            const countsInRange1 = getCountsInRange(range1[0], range1[1]);
            const cpsInRange1 = countsToCps(countsInRange1);
            const countsInRange2 = getCountsInRange(range2[0], range2[1]);
            const cpsInRange2 = countsToCps(countsInRange2);
            const ratio = {};
            for (let i = 0; i < waterfallData.deltas.length; i++) {
                if (cpsInRange1[i] !== undefined && cpsInRange2[i] > 0) {
                    ratio[i] = cpsInRange1[i] / cpsInRange2[i];
                }
            }

            window.cpsData = {
                range1: cpsInRange1,
                range2: cpsInRange2,
                ratio: ratio,
            }

            const plotHeight = constants.cpsPlotHeight / 3;
            cpsCanvas.height = plotHeight * 3;
            renderCpsData(cpsCanvas, getRenderData(cpsInRange1), 0, plotHeight, 'range_1 cps');
            renderCpsData(cpsCanvas, getRenderData(cpsInRange2), plotHeight, plotHeight, 'range_2 cps');
            renderCpsData(cpsCanvas, getRenderData(ratio), plotHeight * 2, plotHeight, 'range_1 / range_2');
        } else {
            cpsToMapButton.disabled = false;
            comparisonToMapButton.disabled = true;
            const countsInRange1 = getCountsInRange(range1[0], range1[1]);
            const cpsInRange1 = countsToCps(countsInRange1);
            const renderData = getRenderData(cpsInRange1);

            window.cpsData = {
                range1: cpsInRange1,
            }

            renderCpsData(cpsCanvas, renderData, 0, cpsCanvas.height, 'range_1 cps');
        }
    }

    function renderCpsData(canvas, data, offset, height, label) {
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = constants.backgroundColor;
        ctx.fillRect(0, offset, canvas.width, height);

        if (!data) {
            return;
        }

        let displayMax = data.max;
        let displayMin = data.min;
        switch (waterfallState.scale) {
            case 'log':
                displayMax = Math.log(displayMax + 0.1);
                displayMin = Math.log(displayMin + 0.1);
                break;
            case 'sqrt':
                displayMax = Math.sqrt(displayMax);
                displayMin = Math.sqrt(displayMin);
                break;
            default:
                break;
        }
        if (displayMax === 0 && displayMin === 0) {
            displayMax = 1;
            displayMin = -1;
        }
        let displayRange = displayMax - displayMin;
        displayMax += constants.cpsExtendRange * (displayRange === 0 ? displayMax : displayRange);
        displayMin -= constants.cpsExtendRange * (displayRange === 0 ? displayMax : displayRange);
        displayRange = displayMax - displayMin;

        // line
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.setLineDash([1, 0]);
        ctx.strokeStyle = constants.lineColor;
        let firstMove = true;
        for (let x = 0; x < waterfallData.deltas.length; x++) {
            if (data.values[x] === undefined) {
                continue;
            }

            let displayValue = data.values[x];
            switch (waterfallState.scale) {
                case 'log':
                    displayValue = Math.log(displayValue + 0.1);
                    break;
                case 'sqrt':
                    displayValue = Math.sqrt(displayValue);
                    break;
                default:
                    break;
            }

            const y = height - ((displayValue - displayMin) / displayRange) * height + offset;

            if (firstMove) {
                ctx.moveTo(x, y);
                firstMove = false;
            } else {
                ctx.lineTo(x, y);
                ctx.moveTo(x, y);
            }
        }
        ctx.stroke();

        // separator line
        if (offset > 0) {
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.strokeStyle = constants.separatorLineColor;
            ctx.moveTo(0, offset - 0.5);
            ctx.lineTo(canvas.width, offset - 0.5);
            ctx.stroke();
        }

        // labels
        const range = data.max - data.min;
        ctx.fillStyle = constants.textColor;
        ctx.textBaseline = 'top';
        ctx.fillText(data.max.toFixed(range < 0.01 ? 4 : 2) + ' (max)', 0, offset);
        ctx.textBaseline = 'bottom';
        ctx.fillText(data.min.toFixed(range < 0.01 ? 4 : 2) + ' (min)', 0, offset + height);
        ctx.textBaseline = 'top';
        ctx.fillText(label + ' (' + waterfallState.scale + ')', canvas.width / 2 - label.length * 2, offset);
    }

    function exportCpsMap() {
        const range = waterfallState.channelRange1;
        if (!range || range.length !== 2) {
            alert('Error: invalid channel range 1.');
            return;
        }
        const energyRange = getEnergyRangeStr(range);
        const description = originalWaterfallData.baseSpectrum.name + ' CP2S: cps in range ' + energyRange;
        const data = exports.getRctrkData(
            description, 
            originalWaterfallData.deltas, 
            range, 
            undefined, 
            waterfallState.channelBinning
        );
        const filename = originalWaterfallData.baseSpectrum.name + '-' + energyRange;

        saveFile(filename + '-cps.rctrk', data, 'text/rctrk');
    }

    function exportComparisonMap() {
        const range = waterfallState.channelRange1;
        if (!range || range.length !== 2) {
            alert('Error: invalid channel range 1.');
            return;
        }
        const compareRange = waterfallState.channelRange2;
        if (!compareRange || compareRange.length !== 2) {
            alert('Error: invalid channel range 2.');
            return;
        }
        const energyRange = getEnergyRangeStr(range);
        const compareEnergyRange = getEnergyRangeStr(compareRange);
        const data = exports.getRctrkData(originalWaterfallData.baseSpectrum.name + 
            ' CP2S: cps comparison for ranges ' + energyRange + '/' + compareEnergyRange, 
            originalWaterfallData.deltas, range, compareRange, waterfallState.channelBinning
        );
        const filename = originalWaterfallData.baseSpectrum.name + '-' + energyRange + compareEnergyRange;

        saveFile(filename + '-cps-comparison.rctrk', data, 'text/rctrk');
    }

    function exportSpectrumRange() {
        const range = waterfallState.spectrumRange;
        if (!range || range.length !== 2) {
            alert('Error: invalid from or to spectrum index.');
            return;
        }

        if (originalWaterfallData.channelBinning !== 1) {
            alert('Export to ' + originalWaterfallData.baseSpectrum.channelCount + ' channels due to channel binning applied by CLI or during import.');
        }
        
        const combinedSpectrum = exports.combineSpectrums(
            originalWaterfallData.deltas, 
            range[0], 
            range[1], 
            originalWaterfallData.baseSpectrum, 
            originalWaterfallData.filename
        );
        const spectrumText = exports.serializeSpectrum(combinedSpectrum);
        const filename = originalWaterfallData.baseSpectrum.name + '-[' + range[0] + ', ' + range[1] + ']';

        saveFile(filename + '-combined.txt', spectrumText, 'text/plain');
    }

    async function spectrumRangeAsBase() {
        const range = waterfallState.spectrumRange;
        if (!range || range.length !== 2) {
            alert('Error: invalid from or to spectrum index.');
            return;
        }
        
        const combinedSpectrum = exports.combineSpectrums(
            originalWaterfallData.deltas, 
            range[0], 
            range[1], 
            originalWaterfallData.baseSpectrum, 
            originalWaterfallData.filename
        );
        originalWaterfallData.baseSpectrum = combinedSpectrum;

        waterfallControl.setSubstractBase(true);
        waterfallControl.markBaseChanged();
        await waterfallControl.applyBinningAndAverageAsync();        
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
        await cps.renderCpsAsync();
    }

    function saveFile(filename, data, type) {
        const blob = new Blob([data], { type: type });
        const elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;
        document.body.appendChild(elem);
        elem.click();
        document.body.removeChild(elem);
    }

    function getEnergyRangeStr(range) {
        return '[' + common.channelToEnergy(range[0]).toFixed(0) + '-' + common.channelToEnergy(range[1]).toFixed(0) + ' keV]';
    }
})();
</script>
		<script>(function(){
    // mouse cursor render
    const previewContainer = document.getElementById('preview-container');
    const wfContainer = document.getElementById('waterfall-container');
    const cpsContainer = document.getElementById('cps-container');
    const waterfallPlot = document.getElementById('waterfall-plot');
    const cpsPlot = document.getElementById('cps-plot');
    const wfHorizontalCursor = document.getElementById('horizontal-cursor');
    const wfVerticalCursor = document.getElementById('vertical-cursor');
    
    wfContainer.addEventListener('scroll', (e) => onWfContainerScroll(e));
    cpsContainer.addEventListener('scroll', (e) => onCpsContainerScroll(e));
    waterfallPlot.addEventListener('mouseleave', e => plotOnMouseLeave(e));
    waterfallPlot.addEventListener('mousemove', e => waterfallOnMouseMove(e));
    cpsPlot.addEventListener('mouseleave', e => plotOnMouseLeave(e));
    cpsPlot.addEventListener('mousemove', e => cpsOnMouseMove(e));

    function plotOnMouseLeave(e) {
        wfHorizontalCursor.style.display = 'none';
        wfVerticalCursor.style.display = 'none';

        waterfallPlot.setAttribute('title', '');
        cpsPlot.setAttribute('title', '');
    }

    function waterfallOnMouseMove(e) {
        wfHorizontalCursor.style.display = 'block';
        wfVerticalCursor.style.display = 'block';

        // channel cursor
        let offsetX = e.offsetX - constants.cursorOffset;
        if (offsetX < constants.timeAxisWidth) {
            offsetX = constants.timeAxisWidth;
        } else if (offsetX > constants.timeAxisWidth + waterfallData.baseSpectrum.channelCount - 1) {
            offsetX = constants.timeAxisWidth + waterfallData.baseSpectrum.channelCount - 1;
        }

        // spectrum cursor
        let offsetY = e.offsetY - constants.cursorOffset;
        if (offsetY < 0) {
            offsetY = 0;
        } else if (e.offsetY >= waterfallData.deltas.length) {
            offsetY = waterfallData.deltas.length - 1;
            offsetY = waterfallData.deltas.length - 1;
        }
        
        // tooltip
        const spectrumIndex = offsetY;
        const channelIndex = offsetX - constants.timeAxisWidth;
        const tooltipText = 'spectrum: ' + spectrumIndex * waterfallState.spectrumBinning * originalWaterfallData.spectrumBinning
            + '\n' + 'channel: ' + channelIndex
            + '\n' + 'energy: ' + common.channelToEnergy(channelIndex).toFixed(1) + ' keV'
            + '\n' + 'time: ' + common.timeToString(waterfallData.deltas[spectrumIndex].timestamp)
            + '\n' + 'duration: ' + waterfallData.deltas[spectrumIndex].duration.toFixed(1) + ' s';
        waterfallPlot.setAttribute('title', tooltipText);

        // vertical line
        const wfContainerRect = wfContainer.getBoundingClientRect();
        wfVerticalCursor.style.left = offsetX + wfContainerRect.left - wfContainer.scrollLeft + window.scrollX;
        if (wfContainerRect.height < waterfallData.deltas.length + constants.channelAxisHeight) {
            wfVerticalCursor.style.height = wfContainerRect.height + 'px';
        } else {
            wfVerticalCursor.style.height = waterfallData.deltas.length + constants.channelAxisHeight + 'px';
        }
        
        // horizontal line
        const cpsContainerRect = cpsContainer.getBoundingClientRect();
        wfHorizontalCursor.style.top = offsetY + wfContainerRect.top - wfContainer.scrollTop + window.scrollY;
        wfHorizontalCursor.style.left = wfContainerRect.left;
        wfHorizontalCursor.style.width = wfContainerRect.width + cpsContainerRect.width + 'px';
    }

    function cpsOnMouseMove(e) {
        wfHorizontalCursor.style.display = 'block';
        wfVerticalCursor.style.display = 'none';

        // spectrum cursor
        let offsetX = e.offsetX - constants.cursorOffset;
        if (offsetX < 0) {
            offsetX = 0;
        } else if (offsetX > waterfallData.deltas.length - 1) {
            offsetX = waterfallData.deltas.length - 1;
        }

        // tooltip
        const spectrumIndex = offsetX;
        let tooltipText = 'spectrum: ' + spectrumIndex * waterfallState.spectrumBinning * originalWaterfallData.spectrumBinning
            + '\n' + 'time: ' + common.timeToString(waterfallData.deltas[spectrumIndex].timestamp)
            + '\n' + 'duration: ' + waterfallData.deltas[spectrumIndex].duration.toFixed(1) + ' s';
        if (cpsData.range1 && cpsData.range1[spectrumIndex] !== undefined) {
            tooltipText += '\n' + 'range1: ' + formatFloat(cpsData.range1[spectrumIndex]) + ' cps';
        }
        if (cpsData.range2 && cpsData.range2[spectrumIndex] !== undefined) {
            tooltipText += '\n' + 'range2: ' + formatFloat(cpsData.range2[spectrumIndex]) + ' cps';
        }
        if (cpsData.ratio && cpsData.ratio[spectrumIndex] !== undefined) {
            tooltipText += '\n' + 'ratio: ' + formatFloat(cpsData.ratio[spectrumIndex]);
        }
        cpsPlot.setAttribute('title', tooltipText);

        // horizontal line
        const wfContainerRect = wfContainer.getBoundingClientRect();
        const cpsContainerRect = cpsContainer.getBoundingClientRect();
        wfHorizontalCursor.style.top = offsetX + cpsContainerRect.top - cpsContainer.scrollTop + window.scrollY;
        wfHorizontalCursor.style.left = wfContainerRect.left;
        wfHorizontalCursor.style.width = wfContainerRect.width + cpsContainerRect.width + 'px';
    }

    function onCpsContainerScroll(event) {
        if (wfContainer.scrollTop !== cpsContainer.scrollTop) {
            wfContainer.scrollTop = cpsContainer.scrollTop;
        }
    }

    function onWfContainerScroll(event) {
        if (cpsContainer.scrollTop !== wfContainer.scrollTop) {
            cpsContainer.scrollTop = wfContainer.scrollTop;
        }

        if (previewContainer.scrollLeft !== wfContainer.scrollLeft) {
            previewContainer.scrollLeft = wfContainer.scrollLeft;
        }
    }

    function formatFloat(val) {
        return val > 0.1
            ? val.toFixed(2)
            : val.toFixed(4);
    }
})();
</script>
		<script>(function(){
    // waterfall binning/average control
    const spectrumBinningInput = document.getElementById('spectrum-binning');
    const channelBinningInput = document.getElementById('channel-binning');
    const movingAverageVerticalInput = document.getElementById('moving-average-vertical');
    const movingAverageHorizontalInput = document.getElementById('moving-average-horizontal');
    spectrumBinningInput.addEventListener('change', e => onSpectrumBinningChange(e.target.value));
    channelBinningInput.addEventListener('change', e => onChannelBinningChange(e.target.value));
    movingAverageVerticalInput.addEventListener('change', e => onVerticalMovingAverageChange(e.target.value));
    movingAverageHorizontalInput.addEventListener('change', e => onHorizontalMovingAverageChange(e.target.value));

    // scale control
    const linBtn = document.getElementById('lin');
    const sqrtBtn = document.getElementById('sqrt');
    const logBtn = document.getElementById('log');
    linBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));
    sqrtBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));
    logBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));

    const blurCheckbox = document.getElementById('blur-waterfall');
    blurCheckbox.addEventListener('change', (e) => onWaterfallBlurChange(e.target.checked));

    const subtractCheckbox = document.getElementById('subtract-base');
    const substractLabel = document.getElementById('subtract-base-label');
    subtractCheckbox.addEventListener('change', (e) => onWaterfallSubtractChange(e.target.checked));

    const maxCpsInput = document.getElementById('max-cps');
    maxCpsInput.addEventListener('change', (e) => onMaxCpsChange(e.target.value));

    const minCpsInput = document.getElementById('min-cps');
    minCpsInput.addEventListener('change', (e) => onMinCpsChange(e.target.value));

    const timezoneInput = document.getElementById('timezone');
    timezoneInput.addEventListener('change', (e) => onTimezoneChange(e.target.value));

    const plotContainer = document.getElementById('plot-container');
    const previewContainer = document.getElementById('preview-container');
    const previewCanvas = document.getElementById('preview-plot');

    const palette = document.getElementById('palette');
    plotContainer.addEventListener('dblclick', (e) => onWaterfallPaletteChange());
    palette.addEventListener('change', (e) => onWaterfallPaletteChange(palette.value));
    
    window.waterfallControl = {
        setSubstractBase: (value) => setSubstractBase(value),
        markBaseChanged: () => markBaseChanged(),
        resetBaseChanged: () => resetBaseChanged(),
        resetWaterfallBinning: (channelBinning) => resetWaterfallBinning(channelBinning),
        resetMovingAverage: () => resetMovingAverage(),
        applyBinningAndAverage: () => applyBinningAndAverage(),
        applyBinningAndAverageAsync: () => {
            return common.executeWithStatusAsync('Processing...', () => applyBinningAndAverage());
        },
        showPreview: () => showPreview(),
        hidePreview: () => hidePreview()
    };

    async function onWaterfallPaletteChange(value) {
        const paletteList = ['iron', 'lime', 'yellow', 'glow', 'gray'];
        if (value) {
            waterfallState.palette = value;   
        } else {
            const selected = paletteList.indexOf(waterfallState.palette);
            if (selected === paletteList.length - 1) {
                waterfallState.palette = paletteList[0];
            } else {
                waterfallState.palette = paletteList[selected + 1];
            }

            palette.value = waterfallState.palette;
        }

        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
    }

    function showPreview() {
        waterfallState.previewEnabled = true;
        plotContainer.classList.add('with-preview');
        previewContainer.style.display = 'block';
        previewCanvas.height = 0;
    }

    function hidePreview() {
        waterfallState.previewEnabled = false;
        plotContainer.classList.remove('with-preview');
        previewContainer.style.display = 'none';
    }

    function setSubstractBase(value) {
        subtractCheckbox.checked = value;
        waterfallState.subtractBase = value;
    }

    function markBaseChanged() {
        if (substractLabel.innerText.indexOf('*') === -1) {
            substractLabel.innerText += '*';
            substractLabel.title = 'base has been set from spectrogram';
        }
    }

    function resetBaseChanged() {
        if (substractLabel.innerText.indexOf('*') !== -1) {
            substractLabel.innerText = substractLabel.innerText.replace('*', '');
            substractLabel.title = '';
        }
    }

    function resetWaterfallBinning(channelBinning) {
        waterfallState.spectrumBinning = 1;
        spectrumBinningInput.value = waterfallState.spectrumBinning;
        
        waterfallState.channelBinning = channelBinning >= originalWaterfallData.channelBinning
            ? channelBinning
            : originalWaterfallData.channelBinning;
        channelBinningInput.value = waterfallState.channelBinning;
        const opts = channelBinningInput.getElementsByTagName('option');
        [...opts].forEach(opt => {
            opt.disabled = parseInt(opt.value) < originalWaterfallData.channelBinning;
        });
    }

    function resetMovingAverage() {
        waterfallState.movingAverageVertical = 0;
        waterfallState.movingAverageHorizontal = 0;
        movingAverageVerticalInput.value = 0;
        movingAverageHorizontalInput.value = 0;
    }

    async function onWaterfallScaleChange(value) {
        waterfallState.scale = value;
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
        await cps.renderCpsAsync();
    }

    async function onWaterfallBlurChange(value) {
        waterfallState.blur = value;
        await waterfall.renderWaterfallImageAsync();
    }

    async function onWaterfallSubtractChange(value) {
        waterfallState.subtractBase = value;
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
        await cps.renderCpsAsync();
    }

    async function onSpectrumBinningChange(value) {
        let newBin = parseInt(value);
        if (isNaN(newBin) || newBin < 1) {
            newBin = 1;
            spectrumBinningInput.value = newBin;
        }

        waterfallState.spectrumBinning = newBin;

        await waterfallControl.applyBinningAndAverageAsync();
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
        await cps.renderCpsAsync();
    }

    async function onChannelBinningChange(value) {
        const newBin = parseInt(value);
        const prevBin = waterfallState.channelBinning;
        waterfallState.channelBinning = newBin;

        await waterfallControl.applyBinningAndAverageAsync();
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();

        // TODO: refactor duplicated code
        const fromChannelInput1 = document.getElementById('from-channel-1');
        const toChannelInput1 = document.getElementById('to-channel-1');
        const fromChannelInput2 = document.getElementById('from-channel-2');
        const toChannelInput2 = document.getElementById('to-channel-2');

        updateInputChannelValue(fromChannelInput1, newBin, prevBin);
        updateInputChannelValue(toChannelInput1, newBin, prevBin);
        updateInputChannelValue(fromChannelInput2, newBin, prevBin);
        updateInputChannelValue(toChannelInput2, newBin, prevBin);

        await cps.renderCpsAsync();
    }

    async function onVerticalMovingAverageChange(value) {
        const windowSize = parseInt(value);
        if (windowSize === waterfallState.movingAverageVertical) {
            return;
        }
        waterfallState.movingAverageVertical = windowSize;

        await waterfallControl.applyBinningAndAverageAsync();
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
        await cps.renderCpsAsync();
    }

    async function onHorizontalMovingAverageChange(value) {
        const windowSize = parseInt(value);
        if (windowSize === waterfallState.movingAverageHorizontal) {
            return;
        }
        waterfallState.movingAverageHorizontal = windowSize;

        await waterfallControl.applyBinningAndAverageAsync();
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
        await cps.renderCpsAsync();
    }

    async function onMaxCpsChange(value) {
        let newVal = parseFloat(value);
        if (isNaN(newVal) || newVal < 1) {
            newVal = 100;
            maxCpsInput.value = newVal;
        }

        waterfallState.maxCpsPercent = newVal;
        if (waterfallState.minCpsPercent > newVal) {
            waterfallState.minCpsPercent = newVal - 1;
            minCpsInput.value = waterfallState.minCpsPercent;
        }

        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
    }

    async function onMinCpsChange(value) {
        let newVal = parseFloat(value);
        if (isNaN(newVal) || newVal < 0) {
            newVal = 0;
            minCpsInput.value = newVal;
        }

        waterfallState.minCpsPercent = newVal;
        if (waterfallState.maxCpsPercent < newVal) {
            waterfallState.maxCpsPercent = newVal + 1;
            maxCpsInput.value = waterfallState.maxCpsPercent;
        }

        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
    }

    async function onTimezoneChange(value) {
        if (value === 'local') {
            waterfallState.timeOffsetHours = common.getLocalTimeOffsetHours();
        } else {
            waterfallState.timeOffsetHours = parseInt(value);
        }
        
        await waterfall.renderWaterfallImageAsync();
    }
    
    function updateInputChannelValue(input, newBin, prevBin) {
        const prevVal = parseInt(input.value);

        if (!isNaN(prevVal)) {
            let newVal = Math.round((prevVal / newBin) * prevBin);
            if (newVal < 0) {
                newVal = 0;
            }
            if (newVal > waterfallData.baseSpectrum.channelCount - 1) {
                newVal = waterfallData.baseSpectrum.channelCount - 1;
            }
            input.value = newVal;
        }
    }

    function applyBinningAndAverage() {
        waterfallData = exports.createWaterfallData(
            originalWaterfallData.baseSpectrum, 
            originalWaterfallData.deltas, 
            waterfallState.channelBinning / originalWaterfallData.channelBinning, 
            waterfallState.spectrumBinning
        );

        applyMovingAverage();
    }

    function applyMovingAverage() {
        // horizontal average
        let windowSize = waterfallState.movingAverageHorizontal;
        let avgDeltas = [];
        for (let i = 0; i < waterfallData.deltas.length; i++) {
            const avgDelta = {
                ...waterfallData.deltas[i],
                channels: new Float32Array(waterfallData.baseSpectrum.channelCount)
            };
            for (let j = 0; j < waterfallData.deltas[i].channels.length; j++) {
                avgDelta.channels[j] = waterfallData.deltas[i].channels[j];
                let appliedSize = 0;
                for (let k = j - windowSize / 2; k <= j + windowSize / 2; k++) {
                    if (k < 0 || k === j) {
                        continue;
                    }
                    if (k >= waterfallData.deltas[i].channels.length) {
                        break;
                    }
                    avgDelta.channels[j] += waterfallData.deltas[i].channels[k];
                    appliedSize++;
                }
                avgDelta.channels[j] /= appliedSize + 1;
            }

            avgDeltas.push(avgDelta);
        }
        waterfallData.deltas = avgDeltas;

        // base spectrum
        const channels = new Float32Array(waterfallData.baseSpectrum.channelCount);
        for (let j = 0; j < waterfallData.baseSpectrum.channels.length; j++) {
            channels[j] = waterfallData.baseSpectrum.channels[j];
            let appliedSize = 0;
            for (let k = j - windowSize / 2; k <= j + windowSize / 2; k++) {
                if (k < 0 || k === j) {
                    continue;
                }
                if (k >= waterfallData.baseSpectrum.channels.length) {
                    break;
                }
                channels[j] += waterfallData.baseSpectrum.channels[k];
                appliedSize++;
            }
            channels[j] /= appliedSize + 1;
        }
        waterfallData.baseSpectrum.channels = channels;

        // vertical average
        windowSize = waterfallState.movingAverageVertical;
        avgDeltas = [];
        for (let i = 0; i < waterfallData.deltas.length; i++) {
            const avgDelta = {
                ...waterfallData.deltas[i],
                channels: new Float32Array(waterfallData.deltas[i].channels)
            };
            for (let j = 0; j < avgDelta.channels.length; j++) {
                let appliedSize = 0;
                for (let k = i - windowSize / 2; k <= i + windowSize / 2; k++) {
                    if (k < 0 || k === i) {
                        continue;
                    }

                    if (k >= waterfallData.deltas.length) {
                        break;
                    }

                    avgDelta.channels[j] += waterfallData.deltas[k].channels[j] * (waterfallData.deltas[i].duration / waterfallData.deltas[k].duration);
                    appliedSize++;
                }

                avgDelta.channels[j] /= appliedSize + 1;
            }

            avgDeltas.push(avgDelta);
        }

        waterfallData.deltas = avgDeltas;
    }
})();
</script>
		<script>(function(){
    // startup - check if we have to run with nodejs prepared data or user loads it in browser
    const uploadControl = document.getElementById('upload-control');
    const infoContainer = document.getElementById('file-info-container');
    const infoSpan = document.getElementById('file-info');
    const overlay = document.getElementById('blocking-overlay');
    const fileInput = document.getElementById('file-input');
    const importChannelBinInput = document.getElementById('import-channel-binning');
    const v6614Checkbox = document.getElementById('v-6.6.14');

    v6614Checkbox.addEventListener('change', (e) => {
        if (e.target.checked) {
            fileInput.setAttribute('multiple', '');
        } else {
            fileInput.removeAttribute('multiple', '');
        }
    });

    fileInput.addEventListener('change', (e) => onFileChange(e.target));
    importChannelBinInput.addEventListener('change', (e) => { 
        fileInput.value = ''; 
    });

    if (window.originalWaterfallData === 'waterfall-data-placeholder') {
        uploadControl.style.display = 'block';
        infoContainer.style.display = 'none';
    } else {
        uploadControl.style.display = 'none';
        overlay.style.display = 'none';
        infoContainer.style.display = 'block';
        infoSpan.innerText = 'Atomspectra file: ' + originalWaterfallData.filename + '; already applied binning - '
            + 'spectrum: ' + originalWaterfallData.spectrumBinning + ', channel: ' + originalWaterfallData.channelBinning;
        
        startupAsync();
    }

    function onFileChange(input) {
        const file = input.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();
        if (v6614Checkbox.checked) {
            let fileIndex = 0;
            let baseSpectrum;
            let deltas = [];

            reader.onload = async (e) => {
				const fileText = e.target.result;
			
				if (fileIndex === 0) {
					baseSpectrum = exports.deserializeSpectrum(fileText);
				}

				if (fileIndex < input.files.length) {
					deltas.push(exports.deserializeSpectrum(fileText));
				}
				
				if ((fileIndex + 1) % 25 === 0) {
					await common.executeWithStatusAsync('Deserializing(' + (fileIndex + 1) + '/' + input.files.length + ')...', () => {});
				}

				if (fileIndex === input.files.length - 1) {
					overlay.style.display = 'none';
					const importChannelBin = parseInt(importChannelBinInput.value);
					const spectrumBin = 1;
					deltas = deltas.sort((d1, d2) => d1.timestamp > d2.timestamp ? 1 : -1);
					window.originalWaterfallData = exports.createWaterfallData(baseSpectrum, deltas, importChannelBin, spectrumBin, file.name);
					
					await startupAsync();
				} else {
					fileIndex++;
					reader.readAsText(input.files[fileIndex]);
				}
            };
        } else {
            reader.onload = async (e) => {
                await common.executeWithStatusAsync('Deserializing...', () => {
                    overlay.style.display = 'none';
                    const fileText = e.target.result;
                    const baseSpectrum = exports.deserializeSpectrum(fileText);
                    const deltaInfo = exports.deserializeDeltas(fileText, baseSpectrum);
                    const deltas = deltaInfo.deltas;

                    const importChannelBin = parseInt(importChannelBinInput.value);
                    const spectrumBin = 1;
                    window.originalWaterfallData = exports.createWaterfallData(baseSpectrum, deltas, importChannelBin, spectrumBin, file.name);
                });

                await startupAsync();
            };
        }

        common.executeWithStatusAsync('Opening file...', () => {
            reader.readAsText(file);
        });
    }

    async function startupAsync() {
        waterfallControl.setSubstractBase(false);
        waterfallControl.resetBaseChanged();
        waterfallControl.resetMovingAverage();
        waterfallControl.resetWaterfallBinning(16);
        await waterfallControl.applyBinningAndAverageAsync();
        cps.initCpsControls();
        await waterfall.renderWaterfallImageAsync();
        await waterfall.renderSpectrumImageAsync();
        await cps.renderCpsAsync();
    }
})();</script>
	</body>
</html>