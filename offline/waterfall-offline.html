<html>
	<head>
		<style>body {
    background: #444;
    color: #CCC;
    margin: 0;
    min-width: 1100px;
    padding: 0 8px;
}
body * {
    font-size: 18px;
    font-family: monospace;
}
select, input {
    background: #444;
    color: #CCC;
}
input[type="number"] {
    border: 1px solid #CCC;
}
.upload-control {
    border-bottom: 1px dotted;
    padding-top: 24px;
    padding-bottom: 4px;
    text-wrap: nowrap;
}
.upload-control input {
    width: 600px;
}
.waterfall-control, .cps-control {
    width: 100%;
    border-bottom: 1px dotted;
    padding: 4px 0;
}
.waterfall-control {
    padding-top: 24px;
}
.row {
    display: inline-block;
    margin-bottom: 12px;
    text-wrap: nowrap;
    width: 100%;
}
.col {
    display: inline-block;
    text-wrap: nowrap;
    width: 280px;
}
.col label {
    margin-left: 4px;
}
.col select {
    margin-left: 16px;
}
.scale-switch {
    display: inline-block;
    margin-right: 16px;
}
.plot-container, .plot-container .cps-container {
    height: calc(100% - 300px); /* - other controls height */
}
.plot-container .waterfall-container {
    display: inline-block;
    height: 100%;
    max-width: calc(100% - 320px); /* cpsPlotWidth in js + scroll */
    overflow-x: scroll;
    overflow-y: auto;
}
.plot-container .cps-container {
    display: inline-block;
    position: absolute;
    overflow-y: auto;
    overflow-x: scroll;
    padding-left: 1px;
    width: 320px; /* cpsPlotWidth in js + scroll */
}
.cps-container .cps-plot {
    position: absolute;
    transform: rotate(90deg); /* veeeeeery hacky, need to rewrite this */
    transform-origin: bottom left;
    top: -300px; /* cpsPlotWidth in js */
}
.horizontal-cursor, .vertical-cursor {
    display: none;
    position: absolute;
    z-index: 1;
}
.horizontal-cursor {
    border-bottom: 1px dotted #777;
    height: 0;
}
.vertical-cursor {
    border-right: 1px dotted #777;
    width: 0;
}
.cps-control .numeric-input {
    margin: 0 4px;
    width: 120px;
}
.cps-left-column {
    display: inline-block;
    width: 400px;
}
.export-button {
    margin-left: 4px;
    width: 400px;
}
.error {
    color: orangered;
}
.blocking-overlay {
    position: absolute;
    background: rgba(100, 100, 100, 0.75);
    top: 56px;
    bottom: 0;
    left: 0;
    right: 0;
    min-width: 1132px;
}</style>
		<script>
			// error console
			window.onerror = function(msg, url, lineNo, columnNo, error) {
				const div = document.createElement('div');
				div.className = "row error";
				div.innerText = msg + ' (line: ' + lineNo + ', column: ' + columnNo + ')';
				document.body.appendChild(div);
			};
		</script>
		<script>
			window.originalWaterfallData = 'waterfall-data-placeholder';
			window.exports = {}; // hack to re-use nodejs modules
			window.require = () => window.exports;
		</script>
		<script>(function () {
	exports.deserializeSpectrum = function(fileText) {
		if (!fileText) {
			throw new Error('spectrum file text is empty');
		}
	
		const lines = fileText.split('\n');
		const format = lines[0];
		const note = lines[1];
		const time = parseInt(lines[2]);
		const time2 = parseInt(lines[3]);
		const latStr = lines[4];
		const lonStr = lines[5];
		const name = lines[6];
		const foundIsotopes = lines[7];
		const duration = parseFloat(lines[8]);
		const channelsCount = parseInt(lines[9]);
		const calibrationOrder = parseInt(lines[10]);
		const calibration = [];
		for (let i = 0; i < calibrationOrder + 1; i++) {
			calibration.push(parseFloat(lines[11 + i]));
		}
	
		let index = 0;
		const channels = [];
		while (index < channelsCount) {
			channels.push(parseInt(lines[12 + calibrationOrder + index]));
			index++;
		}
	
		return {
			format: format,
			note: note,
			timestamp: time,
			timestamp2: time2,
			latStr: latStr,
			lonStr: lonStr,
			name: name,
			foundIsotopes: foundIsotopes,
			duration: duration,
			channelCount: channels.length,
			calibration: calibration,
			channels: channels
		};
	}
	
	exports.serializeSpectrum = function(spectrum) {
		if (!spectrum) {
			throw new Error('spectrum is not provided');
		}
	
		let text = spectrum.format + '\n';
		text += spectrum.note + '\n';
		text += spectrum.timestamp + '\n';
		text += spectrum.timestamp2 + '\n';
		text += spectrum.latStr + '\n';
		text += spectrum.lonStr + '\n';
		text += spectrum.name + '\n';
		text += spectrum.foundIsotopes + '\n';
		text += spectrum.duration + '\n';
		text += spectrum.channelCount + '\n';
		text += (spectrum.calibration.length - 1) + '\n';
		for (let i = 0; i < spectrum.calibration.length; i++) {
			text += spectrum.calibration[i] + '\n';
		}
	
		let index = 0;
		while (index < spectrum.channelCount) {
			text += spectrum.channels[index] + '\n';
			index++;
		}
	
		return text;
	}
	
	exports.deserializeDeltas = function(fileText, baseSpectrum) {
		if (!fileText) {
			throw new Error('spectrum file text is empty');
		}
	
		const lines = fileText.split('\n');
		const deltaLinesCount = 5;
		const deltas = [];
		let deltaIndex = baseSpectrum.calibration.length + baseSpectrum.channelCount + 11; // skip base spectrum
		while (deltaIndex <= lines.length - deltaLinesCount) {
			const delta = readNextDelta(lines, deltaIndex, baseSpectrum.channelCount);
			deltas.push(delta);
			deltaIndex += deltaLinesCount;
		}
	
		return {
			deltas: deltas
		};
	}
	
	exports.reduceSpectrumCount = function(spectrums, spectrumsBinning) {
		if (spectrumsBinning < 1) {
			throw new Error('invalid factor: ' + spectrumsBinning);
		}
	
		if (!spectrums || !spectrums.length) {
			throw new Error('no spectrums provided');
		}
	
		let reduced = [];
		for (let i = 0; i < spectrums.length; i += spectrumsBinning) {
			let summ = { ...spectrums[i], channels: [...spectrums[i].channels] };
			for (let j = 1; j < spectrumsBinning && (i + j) < spectrums.length; j++) {
				for (let k = 0; k < summ.channels.length; k++) {
					summ.channels[k] += spectrums[i + j].channels[k];
				}
	
				summ.duration += spectrums[i + j].duration;
			}
	
			reduced.push(summ);
		}
	
		return reduced;
	}
	
	exports.reduceChannelCount = function(channels, channelBinning) {
		if (channelBinning < 1) {
			throw new Error('invalid channel binning: ' + channelBinning);
		}
	
		if (!channels || !channels.length) {
			throw new Error('no channels provided');
		}
	
		let reduced = [];
		for (let i = 0; i < channels.length; i += channelBinning) {
			let summ = 0;
			for (let j = 0; j < channelBinning && (i + j) < channels.length; j++) {
				summ += channels[i + j];
			}
	
			reduced.push(summ);
		}
	
		return reduced;
	}
	
	exports.getCalibration = function (calibration, channelBinning) {
		const newCalibration = [];
		for (let i = 0; i < calibration.length; i++) {
			newCalibration.push(Math.pow(channelBinning, i) * calibration[i]);
		}
	
		return newCalibration;
	}

	exports.combineSpectrums = function(deltas, fromIndex, toIndex, baseSpectrum, filename) {
		if (fromIndex < 0) {
			fromIndex = 0;
		}

		if (toIndex > deltas.length - 1) {
			toIndex = deltas.length - 1;
		}

		if (fromIndex > toIndex) {
			const tmp = fromIndex;
			fromIndex = toIndex;
			toIndex = tmp;
		}

		const deltasToCombine = deltas.slice(fromIndex, toIndex + 1);
		const combinedDelta = this.reduceSpectrumCount(deltasToCombine, deltasToCombine.length)[0];
		const combinedSpectrum = {
			format: 'FORMAT: 3',
			note: 'Counts: ' + combinedDelta.channels.reduce((a, v) => a += v, 0) + ', '
				+ 'combined from spectrogram ' + filename + ', '
				+ 'from index: ' + fromIndex + ', '
				+ 'to index: ' + toIndex + ', '
				+ 'from time: ' + formatTime(deltas[fromIndex].timestamp) + ', '
				+ 'to time: ' + formatTime(deltas[toIndex].timestamp),
			timestamp: combinedDelta.timestamp,
			timestamp2: '0',
			latStr: '0.0',
			lonStr: '0.0',
			name: baseSpectrum.name,
			foundIsotopes: '',
			duration: combinedDelta.duration,
			channelCount: combinedDelta.channels.length,
			calibration: baseSpectrum.calibration,
			channels: combinedDelta.channels
		};
		
		return combinedSpectrum;
	}
	
	function readNextDelta(lines, fromIndex, channelCount) {
		const timestamp = parseInt(lines[fromIndex]);
		const lat = parseFloat(lines[fromIndex + 1]);
		const lon = parseFloat(lines[fromIndex + 2]);
		const duration = parseFloat(lines[fromIndex + 3]);
		const channels = lines[fromIndex + 4]
			.split('\t')
			.slice(0, channelCount)
			.map(str => parseInt(str));
	
		return {
			timestamp: timestamp,
			duration: duration,
			lat: lat,
			lon: lon,
			channels: channels
		}
	}
	
	function formatTime(timestamp) {
		const utcISO = new Date(timestamp).toISOString();

		return utcISO.split('T').join(' ').split('.')[0] + ' UTC';
	}
})();
</script>
		<script>(function(){
	const sp = require('./spectrum.js');

	exports.createWaterfallData = function(baseSpectrum, deltas, channelBinning, spectrumBinning, filename) {
		const baseChannels = sp.reduceChannelCount(baseSpectrum.channels, channelBinning);
		let waterfall = {
			deltas: [],
			baseSpectrum: {
				...baseSpectrum,
				channels: baseChannels,
				channelCount: baseChannels.length,
				calibration: sp.getCalibration(baseSpectrum.calibration, channelBinning)
			},
			channelBinning: channelBinning,
			spectrumBinning: spectrumBinning,
			filename: filename
		};

		sp.reduceSpectrumCount(deltas, spectrumBinning).forEach(delta8k => {
			waterfall.deltas.push({
				...delta8k,
				channels: sp.reduceChannelCount(delta8k.channels, channelBinning)
			});
		});

		return waterfall;
	}
})();
</script>
		<script>(function () {
	const sp = require('./spectrum.js');

	exports.createRcspgData = function(baseSpectrum, deltas) {
		if (!baseSpectrum || !deltas || deltas.length === 0) {
			throw new Error('no deltas provided for rcspg convertion')
		}

		const fromTimestamp = deltas[0].timestamp;
		const toTimestamp = deltas[deltas.length - 1].timestamp;

		// header
		const utcISO = new Date(fromTimestamp).toISOString();
		const formattedUTC = utcISO.split('T').join(' ').split('.')[0] + ' UTC';
		const spgName = baseSpectrum.name;
		const spgTime = formattedUTC;
		let rcspgData = 'Spectrogram: ' + spgName + 
						'\tTime: ' + spgTime + 
						'\tTimestamp: ' + filetimeFromJSTime(fromTimestamp) + // just in case to avoid any potential division by zero
						'\tAccumulation time: ' + Math.floor((toTimestamp - fromTimestamp) / 1000) + 
						'\tChannels: 1024\tDevice serial: unknown\tFlags: 1\tComment: exported from atomspectra data';

		const calibration = sp.getCalibration(baseSpectrum.calibration, 8);
		// base spectrum, zero duration, y=x calibration, all zero channels
		let a0 = 0;
		let a1 = 1;
		let a2 = 0;
		switch (calibration.length) {
			case 2:
				a0 = calibration[0];
				a1 = calibration[1];
				break;
			case 3:
				a0 = calibration[0];
				a1 = calibration[1];
				a2 = calibration[2];
				break;
			default:
				console.warn('calibration polynom order (' + calibration.length + ') is not supported, y=x applied');
		}

		// TODO: write base spectrum
		rcspgData += '\nSpectrum: ' +
					/*int32 duration*/'00 00 00 00' + ' ' +
					/*float A0*/getBigEndianFloat(a0) + ' ' +
					/*float A1*/getBigEndianFloat(a1) + ' ' +
					/*float A2*/getBigEndianFloat(a2) + ' ' +
					Array(1024).fill('00 00 00 00').join(' ');

		// deltas
		deltas.forEach(delta => {
			const channels = sp.reduceChannelCount(delta.channels, 8);
			rcspgData += '\n' + filetimeFromJSTime(delta.timestamp);
			rcspgData += '\t' + Math.round(delta.duration);
			channels.forEach(channel => {
			rcspgData += '\t' + channel;
			});
		});

		return rcspgData;
	}

	exports.getRctrkData = function(name, deltas, range1, range2, channelBin) {
		let rctrkData = 'Track: ' + name + '\tAtom Spectra spectrogram\t \tEC\n';
		rctrkData += 'Timestamp\tTime\tLatitude\tLongitude\tAccuracy\tDoseRate\tCountRate\tComment\n';
		deltas.forEach(delta8k => {
			const channels = sp.reduceChannelCount(delta8k.channels, channelBin);
			let newLine = '';
			// ex: '133594869443100000	2024-05-06 16:35:44	60.0006352	30.3515997	6.79	13.3	9.98	 '
			newLine += filetimeFromJSTime(delta8k.timestamp).toString() + '\t';
			newLine += formatDate(delta8k.timestamp) + '\t';
			newLine += delta8k.lat.toFixed(8) + '\t';
			newLine += delta8k.lon.toFixed(8) + '\t';
			newLine += '0.0\t'; // accuracy
			newLine += '0.0\t'; // doserate
			let cps = cpsInRange(channels, delta8k.duration, range1);
			if (range2) {
				let cps2 = cpsInRange(channels, delta8k.duration, range2);
				if (cps2 > 0) {
					cps /= cps2;
				} else {
					cps = 0;
				}
			} 
			newLine += cps.toFixed(4) + '\t'; // cps
			newLine += ' \n'; // comment

			if (cps > 0 && (delta8k.lat !== 0 && delta8k.lon !== 0)) {
				rctrkData += newLine;
			}
		});

		return rctrkData;
	}

	function getBigEndianFloat(value) {
		const getHex = i => ('00' + i.toString(16)).slice(-2);

		var view = new DataView(new ArrayBuffer(4));
		view.setFloat32(0, value);
		const result = Array
			.apply(null, { length: 4 })
			.map((_, i) => getHex(view.getUint8(i)))
			.reverse()
			.join(' ');

		return result;
	}

	function filetimeFromJSTime(jsTime) {  
		return jsTime * 1e4 + 116444736e9;
	}

	function formatDate(ts) {
		const splitDate = new Date(ts).toISOString().split('T');

		return splitDate[0] + ' ' + splitDate[1].split('.')[0];
	}

	function cpsInRange(channels, duration, range) {
		return channels.slice(range[0], range[1] + 1).reduce((a, v) => a + v, 0) / duration;
	}
})();</script> <!-- to be replaced with atom.js -->
	</head>
	<body>
		<div id="blocking-overlay" class="blocking-overlay"></div>
		<div id="upload-control" class="upload-control">
			<span>Select atomspectra file to render:</span>
			<input id="file-input" type="file" accept=".txt" name="files">
		</div>
		<div id="file-info-container" class="upload-control">
			<span id="file-info"></span>
		</div>
		<div id="waterfall-control" class="waterfall-control">
			<div class="row">
				<div class="col">
					<input type="radio" id="lin" name="scale" value="lin">
					<label for="lin">LIN</label>
					<input type="radio" id="sqrt" name="scale" value="sqrt" checked>
					<label for="sqrt">SQRT</label>
					<input type="radio" id="log" name="scale" value="log">
					<label for="log">LOG</label>
				</div>
				<div class="col">
					<label for="spectrum-binning">Spectrum binning:</label>
					<select name="spectrum-binning" id="spectrum-binning">
						<option value="1">1</option>
						<option value="2">2</option>
						<option value="3">3</option>
						<option value="4">4</option>
						<option value="5">5</option>
						<option value="6">6</option>
						<option value="7">7</option>
						<option value="8">8</option>
						<option value="9">9</option>
						<option value="10">10</option>
						<option value="25">25</option>
						<option value="50">50</option>
						<option value="100">100</option>
					</select>
				</div>
				<div class="col">
					<label for="channel-binning">Channel binning:</label>
					<select name="channel-binning" id="channel-binning">
						<option value="1">1</option>
						<option value="2">2</option>
						<option value="4">4</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
				</div>
				<div class="col">
					<label for="moving-average">Moving average:</label>
					<select name="moving-average" id="moving-average">
						<option value="0">0</option>
						<option value="2">2</option>
						<option value="4">4</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
				</div>
			</div>
			<div class="row">
				<div class="col">
					<input type="checkbox" id="blur-waterfall" name="blur-waterfall"/>
					<label for="blur-waterfall">Blur</label>
				</div>
				<div class="col">
					<input type="checkbox" id="subtract-base" name="subtract-base"/>
					<label for="subtract-base">Subtract base spectrum</label>
				</div>
				<div class="col">
					<label for="max-cps">Scale maximum:</label>
					<select name="max-cps" id="max-cps">
						<option value="100">100%</option>
						<option value="75">75%</option>
						<option value="50">50%</option>
						<option value="25">25%</option>
						<option value="10">10%</option>
						<option value="5">5%</option>
						<option value="1">1%</option>
					</select>
				</div>
			</div>
		</div>
		<div id="plot-container" class="plot-container">
			<div id="horizontal-cursor" class="horizontal-cursor"></div>
			<div id="vertical-cursor" class="vertical-cursor"></div>
			<div id="waterfall-container" class="waterfall-container">
				<canvas id="waterfall-plot" class="plot" width="0" height="0"></canvas>
			</div>
			<div id="cps-container" class="cps-container">
				<canvas id="cps-plot" class="cps-plot" width="0" height="0"></canvas>
			</div>
		</div>
		<div id="cps-control" class="cps-control">
			<div class="row">
				<button id="render-cps" class="cps-left-column">CPS trend in channel range:</button> 
				<input type="number" id="from-channel-1" class="numeric-input"/>-<input type="number" id="to-channel-1" class="numeric-input"/>
				<button id="export-cps-map" class="export-button" disabled>Range 1 cps to map</button>
			</div>
			<div class="row">
				<div class="cps-left-column">
					<input type="checkbox" id="cps-comparison" name="cps-comparison"/>
					<label for="cps-comparison">Compare to CPS in channel range:</label>
				</div>
				<input type="number" id="from-channel-2" class="numeric-input"/>-<input type="number" id="to-channel-2" class="numeric-input"/>
				<button id="export-comparison-map" class="export-button" disabled>Range 1/range 2 comparison to map</button>
			</div>
			<div class="row">
				<div class="cps-left-column">
					<input type="checkbox" id="dotted-trend" name="dotted-trend"/>
					<label for="dotted-trend">Dotted</label>
				</div>
				<input type="number" id="from-spectrum" class="numeric-input" placeholder="from index"/>-<input type="number" id="to-spectrum" class="numeric-input" placeholder="to index"/>
				<button id="export-spectrum-range" class="export-button">Spectrogram range to spectrum</button>
			</div>
		</div>
		<script>(function () {
    // display configuration/state
    window.constants = {
        timeAxisWidth: 150, // note: the same in css
        timestampHeight: 20,
        timestampTickWidth: 10,
        channelAxisHeight: 32,
        channelAxisTickHeight: 4,
        backgroundColor: 'black',
        textColor: 'lightgray',
        lineColor: 'lightgray',
        separatorLineColor: '#777',
        dotColor: 'white',
        cpsPlotHeight: 300,
        cpsExtendRange: 0.1,
        blurRadius: 1,
        cursorOffset: 3,
    };
    window.waterfallState = {
        scale: 'sqrt',
        spectrumBinning: 1,
        channelBinning: 1,
        blur: false,
        subtractBase: false,
        movingAverage: 0,
        maxCpsPercent: 100,
    };
    window.common = {
        timeToString: timestamp => {
            const utcISO = new Date(timestamp).toISOString();

            return utcISO.split('T').join(' ').split('.')[0] + ' UTC';
        },
        channelToEnergy: channel => {
            return waterfallData.baseSpectrum.calibration.reduce((e, c, i) => e += Math.pow(channel, i) * c, 0);
        }
    }
})();
</script>
		<script>(function(){
    // waterfall plot render
    window.waterfall = {
        renderWaterfallImage: () => renderWaterfallImage(),
    }

    function hexToRGB(hex) {
        var r = parseInt(hex.slice(1, 3), 16),
            g = parseInt(hex.slice(3, 5), 16),
            b = parseInt(hex.slice(5, 7), 16);
        
            return [r, g, b];
    }		

    function renderWaterfallImage() {
        const canvas = document.getElementById('waterfall-plot');
        canvas.width = waterfallData.baseSpectrum.channelCount + constants.timeAxisWidth;
        canvas.height = waterfallData.deltas.length + constants.channelAxisHeight;

        const ironPaletteHex = [
            "#00000a","#000014","#00001e","#000025","#00002a","#00002e","#000032","#000036",
            "#00003a","#00003e","#000042","#000046","#00004a","#00004f","#000052","#010055",
            "#010057","#020059","#02005c","#03005e","#040061","#040063","#050065","#060067",
            "#070069","#08006b","#09006e","#0a0070","#0b0073","#0c0074","#0d0075","#0d0076",
            "#0e0077","#100078","#120079","#13007b","#15007c","#17007d","#19007e","#1b0080",
            "#1c0081","#1e0083","#200084","#220085","#240086","#260087","#280089","#2a0089",
            "#2c008a","#2e008b","#30008c","#32008d","#34008e","#36008e","#38008f","#390090",
            "#3b0091","#3c0092","#3e0093","#3f0093","#410094","#420095","#440095","#450096",
            "#470096","#490096","#4a0096","#4c0097","#4e0097","#4f0097","#510097","#520098",
            "#540098","#560098","#580099","#5a0099","#5c0099","#5d009a","#5f009a","#61009b",
            "#63009b","#64009b","#66009b","#68009b","#6a009b","#6c009c","#6d009c","#6f009c",
            "#70009c","#71009d","#73009d","#75009d","#77009d","#78009d","#7a009d","#7c009d",
            "#7e009d","#7f009d","#81009d","#83009d","#84009d","#86009d","#87009d","#89009d",
            "#8a009d","#8b009d","#8d009d","#8f009c","#91009c","#93009c","#95009c","#96009b",
            "#98009b","#99009b","#9b009b","#9c009b","#9d009b","#9f009b","#a0009b","#a2009b",
            "#a3009b","#a4009b","#a6009a","#a7009a","#a8009a","#a90099","#aa0099","#ab0099",
            "#ad0099","#ae0198","#af0198","#b00198","#b00198","#b10197","#b20197","#b30196",
            "#b40296","#b50295","#b60295","#b70395","#b80395","#b90495","#ba0495","#ba0494",
            "#bb0593","#bc0593","#bd0593","#be0692","#bf0692","#bf0692","#c00791","#c00791",
            "#c10890","#c10990","#c20a8f","#c30a8e","#c30b8e","#c40c8d","#c50c8c","#c60d8b",
            "#c60e8a","#c70f89","#c81088","#c91187","#ca1286","#ca1385","#cb1385","#cb1484",
            "#cc1582","#cd1681","#ce1780","#ce187e","#cf187c","#cf197b","#d01a79","#d11b78",
            "#d11c76","#d21c75","#d21d74","#d31e72","#d32071","#d4216f","#d4226e","#d5236b",
            "#d52469","#d62567","#d72665","#d82764","#d82862","#d92a60","#da2b5e","#da2c5c",
            "#db2e5a","#db2f57","#dc2f54","#dd3051","#dd314e","#de324a","#de3347","#df3444",
            "#df3541","#df363d","#e0373a","#e03837","#e03933","#e13a30","#e23b2d","#e23c2a",
            "#e33d26","#e33e23","#e43f20","#e4411d","#e4421c","#e5431b","#e54419","#e54518",
            "#e64616","#e74715","#e74814","#e74913","#e84a12","#e84c10","#e84c0f","#e94d0e",
            "#e94d0d","#ea4e0c","#ea4f0c","#eb500b","#eb510a","#eb520a","#eb5309","#ec5409",
            "#ec5608","#ec5708","#ec5808","#ed5907","#ed5a07","#ed5b06","#ee5c06","#ee5c05",
            "#ee5d05","#ee5e05","#ef5f04","#ef6004","#ef6104","#ef6204","#f06303","#f06403",
            "#f06503","#f16603","#f16603","#f16703","#f16803","#f16902","#f16a02","#f16b02",
            "#f16b02","#f26c01","#f26d01","#f26e01","#f36f01","#f37001","#f37101","#f37201",
            "#f47300","#f47400","#f47500","#f47600","#f47700","#f47800","#f47a00","#f57b00",
            "#f57c00","#f57e00","#f57f00","#f68000","#f68100","#f68200","#f78300","#f78400",
            "#f78500","#f78600","#f88700","#f88800","#f88800","#f88900","#f88a00","#f88b00",
            "#f88c00","#f98d00","#f98d00","#f98e00","#f98f00","#f99000","#f99100","#f99200",
            "#f99300","#fa9400","#fa9500","#fa9600","#fb9800","#fb9900","#fb9a00","#fb9c00",
            "#fc9d00","#fc9f00","#fca000","#fca100","#fda200","#fda300","#fda400","#fda600",
            "#fda700","#fda800","#fdaa00","#fdab00","#fdac00","#fdad00","#fdae00","#feaf00",
            "#feb000","#feb100","#feb200","#feb300","#feb400","#feb500","#feb600","#feb800",
            "#feb900","#feb900","#feba00","#febb00","#febc00","#febd00","#febe00","#fec000",
            "#fec100","#fec200","#fec300","#fec400","#fec500","#fec600","#fec700","#fec800",
            "#fec901","#feca01","#feca01","#fecb01","#fecc02","#fecd02","#fece03","#fecf04",
            "#fecf04","#fed005","#fed106","#fed308","#fed409","#fed50a","#fed60a","#fed70b",
            "#fed80c","#fed90d","#ffda0e","#ffda0e","#ffdb10","#ffdc12","#ffdc14","#ffdd16",
            "#ffde19","#ffde1b","#ffdf1e","#ffe020","#ffe122","#ffe224","#ffe226","#ffe328",
            "#ffe42b","#ffe42e","#ffe531","#ffe635","#ffe638","#ffe73c","#ffe83f","#ffe943",
            "#ffea46","#ffeb49","#ffeb4d","#ffec50","#ffed54","#ffee57","#ffee5b","#ffee5f",
            "#ffef63","#ffef67","#fff06a","#fff06e","#fff172","#fff177","#fff17b","#fff280",
            "#fff285","#fff28a","#fff38e","#fff492","#fff496","#fff49a","#fff59e","#fff5a2",
            "#fff5a6","#fff6aa","#fff6af","#fff7b3","#fff7b6","#fff8ba","#fff8bd","#fff8c1",
            "#fff8c4","#fff9c7","#fff9ca","#fff9cd","#fffad1","#fffad4","#fffbd8","#fffcdb",
            "#fffcdf","#fffde2","#fffde5","#fffde8","#fffeeb","#fffeee","#fffef1","#fffef4",
            "#fffff6"
        ];
        const ironPaletteRGB = ironPaletteHex.map(c => hexToRGB(c));

        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        ctx.fillStyle = constants.backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        let maxCps = 0;
        waterfallData.deltas.forEach((delta, deltaIndex) => {
            delta.channels.forEach((channelValue, channelIndex) => {
                if (!channelValue) {
                    return;
                }

                let cps = channelValue / delta.duration;
                // TODO: duplicated code
                if (waterfallState.subtractBase) {
                    const baseCps = waterfallData.baseSpectrum.channels[channelIndex] / waterfallData.baseSpectrum.duration;
                    cps -= baseCps;
                    if (cps < 0) {
                        cps = 0;
                    }
                }

                maxCps = Math.max(maxCps, cps);
            });
        });

        // waterfall render
        const imageData = ctx.getImageData(constants.timeAxisWidth, 0, waterfallData.baseSpectrum.channelCount, waterfallData.deltas.length);
        waterfallData.deltas.forEach((delta, deltaIndex) => {
            delta.channels.forEach((channelValue, channelIndex) => {
                if (!channelValue) {
                    return;
                }

                let cps = channelValue / delta.duration;
                // TODO: duplicated code
                if (waterfallState.subtractBase) {
                    const baseCps = waterfallData.baseSpectrum.channels[channelIndex] / waterfallData.baseSpectrum.duration;
                    cps -= baseCps;
                    if (cps < 0) {
                        cps = 0;
                    }
                }

                let linearColorIndex = Math.round((cps / (maxCps * waterfallState.maxCpsPercent / 100)) * (ironPaletteRGB.length - 1));
                if (linearColorIndex > ironPaletteRGB.length - 1) {
                    linearColorIndex = ironPaletteRGB.length - 1;
                }

                let colorIndex;
                switch (waterfallState.scale) {
                    case 'log':
                        colorIndex = Math.round((Math.log(linearColorIndex + 2) / Math.log(ironPaletteRGB.length)) * (ironPaletteRGB.length - 1));
                        break;
                    case 'sqrt':
                        colorIndex = Math.round((Math.sqrt(linearColorIndex + 2) / Math.sqrt(ironPaletteRGB.length)) * (ironPaletteRGB.length - 1));
                        break;
                    default:
                        colorIndex = linearColorIndex;
                }

                const rgbColor = ironPaletteRGB[colorIndex];
                const pxOffset = (deltaIndex * waterfallData.baseSpectrum.channelCount + channelIndex) * 4;
                imageData.data[pxOffset + 0] = rgbColor[0];
                imageData.data[pxOffset + 1] = rgbColor[1];
                imageData.data[pxOffset + 2] = rgbColor[2];
                imageData.data[pxOffset + 3] = 255;
            });
        });
        ctx.putImageData(imageData, constants.timeAxisWidth, 0);

        if (waterfallState.blur) {
            const blurData = ctx.createImageData(imageData.width, imageData.height);
            const radius = constants.blurRadius;
            for (let x = 0; x < imageData.width; x++) {
                for (let y = 0; y <= imageData.height; y++) {
                    let r = 0;
                    let g = 0;
                    let b = 0;
                    for (let ky = -radius; ky <= radius; ++ky) {
                        for (let kx = -radius; kx <= radius; ++kx) {
                            const sourcePxOffset = ((y + ky) * imageData.width + (x + kx)) * 4;
                            if (sourcePxOffset < 0 || sourcePxOffset > imageData.data.length - 1) {
                                continue;
                            }

                            r += imageData.data[sourcePxOffset + 0];
                            g += imageData.data[sourcePxOffset + 1];
                            b += imageData.data[sourcePxOffset + 2];
                        }
                    }
                    
                    const destPxOffset = (y * blurData.width + x) * 4;
                    const coeff = Math.pow(radius + 1, 2) * 2.1;
                    blurData.data[destPxOffset + 0] = r / coeff;
                    blurData.data[destPxOffset + 1] = g / coeff;
                    blurData.data[destPxOffset + 2] = b / coeff;
                    blurData.data[destPxOffset + 3] = 255;
                }
            }

            ctx.putImageData(blurData, constants.timeAxisWidth, 0);
        }

        // time axis
        const timestamps = waterfallData.deltas.map(d => d.timestamp);
        for (let tsIndex = 0; tsIndex < timestamps.length; tsIndex += constants.timestampHeight) {
            const timestamp = timestamps[tsIndex];
            ctx.textBaseline = 'top';
            ctx.fillStyle = constants.textColor;
            let label = common.timeToString(timestamp);
            label += ': ' + tsIndex * waterfallState.spectrumBinning * originalWaterfallData.spectrumBinning;
            ctx.fillText(label, 0, tsIndex);

            // label tick
            const tickWidth = tsIndex % 100 === 0
                ? constants.timestampTickWidth
                : constants.timestampTickWidth / 2;
            for (let x = constants.timeAxisWidth - tickWidth; x < constants.timeAxisWidth; x++) {
                ctx.fillRect(x, tsIndex, 1, 1);
            }
        }

        // calculate energy for each channel
        const allEnergies = [];
        for (let i = 0; i < waterfallData.baseSpectrum.channelCount; i++) {
            const energy = common.channelToEnergy(i);
            allEnergies.push(energy);
        }

        // calculate channels for 0, 100, 200, 300... enegries 
        const renderEnergies = {};
        for (let energy = 0, channel = 0; energy < allEnergies[allEnergies.length - 1]; energy += 100) {
            while (allEnergies[channel] < energy) {
                channel++;
            }
            renderEnergies[channel] = energy;
        }

        // energy axis render
        const energyAxisBaseline = waterfallData.deltas.length;
        const channelAxisBaseline = waterfallData.deltas.length + constants.channelAxisHeight / 2;
        let kevRendered = false;
        for (let x = constants.timeAxisWidth; x < canvas.width; x++) {
            const channelNumber = x - constants.timeAxisWidth;
            const energy = renderEnergies[channelNumber];

            if (energy != undefined && energy % 500 === 0) {
                ctx.textBaseline = 'top';
                ctx.fillStyle = constants.textColor;
                const label = kevRendered ? energy.toString() : energy + ' keV';
                ctx.fillText(label, x, energyAxisBaseline + constants.channelAxisTickHeight);
                kevRendered = true;
            }

            if (energy != undefined && energy % 100 === 0) {
                const tickHeight = energy % 500 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
                for (let y = energyAxisBaseline; y < energyAxisBaseline + tickHeight; y++) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            if (channelNumber % 100 === 0) {
                ctx.textBaseline = 'top';
                ctx.fillStyle = constants.textColor;
                const label = channelNumber === 0 ? channelNumber + ' channel' : channelNumber.toString();
                ctx.fillText(label, x, channelAxisBaseline + constants.channelAxisTickHeight);
            }

            if (channelNumber % 10 === 0) {
                const tickHeight = channelNumber % 50 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
                for (let y = channelAxisBaseline; y < channelAxisBaseline + tickHeight; y++) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    }
})();</script>
		<script>(function(){
    // cps plot render
    const fromChannelInput1 = document.getElementById('from-channel-1');
    const toChannelInput1 = document.getElementById('to-channel-1');
    const dottedCheckbox = document.getElementById('dotted-trend');
    const fromChannelInput2 = document.getElementById('from-channel-2');
    const toChannelInput2 = document.getElementById('to-channel-2');
    const fromSpectrumInput = document.getElementById('from-spectrum');
    const toSpectrumInput = document.getElementById('to-spectrum');
    const compareCheckbox = document.getElementById('cps-comparison');
    const cpsToMapButton = document.getElementById('export-cps-map');
    const comparisonToMapButton = document.getElementById('export-comparison-map');
    const spectrogramToSpectrumButton = document.getElementById('export-spectrum-range');
    const renderCpsButton = document.getElementById('render-cps');

    cpsToMapButton.addEventListener('click', () => exportCpsMap());
    comparisonToMapButton.addEventListener('click', () => exportComparisonMap());
    spectrogramToSpectrumButton.addEventListener('click', () => exportSpectrumRange());
    renderCpsButton.addEventListener('click', () => renderCps());
    
    window.cps = {
        initCpsControls: () => initCpsControls(),
        renderCps: () => renderCps()
    }

    function initCpsControls() {
        fromChannelInput1.value = 0;
        toChannelInput1.value = waterfallData.baseSpectrum.channelCount - 1;
        fromChannelInput2.value = 0;
        toChannelInput2.value = waterfallData.baseSpectrum.channelCount - 1;
    }

    function getCountsInRange(from, to) {
        from = from < 0 ? 0 : from;
        to = to >= waterfallData.baseSpectrum.channelCount 
            ? waterfallData.baseSpectrum.channelCount - 1
            : to; 

        const countsInRange = {};
        waterfallData.deltas.forEach((delta, deltaIndex) => {
            for (let ci = from; ci <= to; ci++) {
                if (countsInRange[deltaIndex] === undefined) {
                    countsInRange[deltaIndex] = delta.channels[ci];
                } else {
                    countsInRange[deltaIndex] += delta.channels[ci];
                }

                if (waterfallState.subtractBase) {
                    countsInRange[deltaIndex] -= waterfallData.baseSpectrum.channels[ci] * (delta.duration / waterfallData.baseSpectrum.duration);
                }
            }

            if (countsInRange[deltaIndex] < 0) {
                countsInRange[deltaIndex] = 0;
            }
        });
        
        return countsInRange;
    }
    
    function countsToCps(countsInRange) {
        const cpsInRange = {};
        Object.keys(countsInRange).forEach(deltaIndex => {
            cpsInRange[deltaIndex] = countsInRange[deltaIndex] / waterfallData.deltas[deltaIndex].duration;
        });
        
        return cpsInRange;
    }
    
    function getRenderData(valuesInRange) {
        let max = 0;
        let min = Infinity;
        for (let i = 0; i < waterfallData.deltas.length; i++) {
            if (valuesInRange[i] === undefined) {
                continue;
            }

            max = Math.max(max, valuesInRange[i]);
            min = Math.min(min, valuesInRange[i]);
        }

        if (max === 0 && min === 0) {
            max = 1;
            min = -1;
        }
        const range = max - min;
        max += constants.cpsExtendRange * (range === 0 ? max : range);
        min -= constants.cpsExtendRange * (range === 0 ? max : range);
    
        return {
            values: valuesInRange,
            max: max,
            min: min
        }
    }

    function renderCps() {
        const cpsCanvas = document.getElementById('cps-plot');
        cpsCanvas.width = waterfallData.deltas.length + constants.channelAxisHeight;
        cpsCanvas.height = constants.cpsPlotHeight;
    
        const fromChannel1 = parseInt(fromChannelInput1.value);
        const toChannel1 = parseInt(toChannelInput1.value);
        if (isNaN(fromChannel1) || isNaN(toChannel1) || fromChannel1 > toChannel1) {
            cpsToMapButton.disabled = true;
            comparisonToMapButton.disabled = true;
            renderCpsData(cpsCanvas);
            return;
        }
        
        const fromChannel2 = parseInt(fromChannelInput2.value);
        const toChannel2 = parseInt(toChannelInput2.value);
        if (compareCheckbox.checked && (isNaN(fromChannel2) || isNaN(toChannel2) || fromChannel2 > toChannel2)) {
            cpsToMapButton.disabled = true;
            comparisonToMapButton.disabled = true;
            renderCpsData(cpsCanvas);
            return;
        }

        if (compareCheckbox.checked) {
            comparisonToMapButton.disabled = false;
            cpsToMapButton.disabled = false;
            const countsInRange1 = getCountsInRange(fromChannel1, toChannel1);
            const cpsInRange1 = countsToCps(countsInRange1);
            const countsInRange2 = getCountsInRange(fromChannel2, toChannel2);
            const cpsInRange2 = countsToCps(countsInRange2);
            const ratio = {};
            for (let i = 0; i < waterfallData.deltas.length; i++) {
                if (cpsInRange1[i] !== undefined && cpsInRange2[i] > 0) {
                    ratio[i] = cpsInRange1[i] / cpsInRange2[i];
                }
            }

            const plotHeight = constants.cpsPlotHeight / 3;
            cpsCanvas.height = plotHeight * 3;
            renderCpsData(cpsCanvas, getRenderData(cpsInRange1), 0, plotHeight, 'range 1 cps');
            renderCpsData(cpsCanvas, getRenderData(cpsInRange2), plotHeight, plotHeight, 'range 2 cps');
            renderCpsData(cpsCanvas, getRenderData(ratio), plotHeight * 2, plotHeight, 'range 1 / range 2');
        } else {
            cpsToMapButton.disabled = false;
            comparisonToMapButton.disabled = true;
            const countsInRange1 = getCountsInRange(fromChannel1, toChannel1);
            const cpsInRange1 = countsToCps(countsInRange1);
            const renderData = getRenderData(cpsInRange1);

            renderCpsData(cpsCanvas, renderData, 0, cpsCanvas.height, 'range 1 cps');
        }
    }

    function renderCpsData(canvas, data, offset, height, label) {			
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = constants.backgroundColor;
        ctx.fillRect(0, offset, canvas.width, height);

        if (!data) {
            return;
        }

        const range = data.max - data.min;
        if (dottedCheckbox.checked) {
            // points
            ctx.fillStyle = constants.dotColor;
            for (let x = 0; x < waterfallData.deltas.length; x++) {
                if (data.values[x] === undefined) {
                    continue;
                }

                const y = height - ((data.values[x] - data.min) / range) * height + offset;
                ctx.fillRect(x, y, 1, 1);
            }
        } else {
            // lines
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.setLineDash([1, 0]);
            ctx.strokeStyle = constants.lineColor;
            let firstMove = true;
            for (let x = 0; x < waterfallData.deltas.length; x++) {
                if (data.values[x] === undefined) {
                    continue;
                }

                const y = height - ((data.values[x] - data.min) / range) * height + offset;

                if (firstMove) {
                    ctx.moveTo(x, y);
                    firstMove = false;
                } else {
                    ctx.lineTo(x, y);
                    ctx.moveTo(x, y);
                }
            }
            ctx.stroke();
        }

        // separator line
        if (offset > 0) {
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.strokeStyle = constants.separatorLineColor;
            ctx.moveTo(0, offset - 0.5);
            ctx.lineTo(canvas.width, offset - 0.5);
            ctx.stroke();
        }

        // labels
        ctx.fillStyle = constants.textColor;
        ctx.textBaseline = 'top';
        ctx.fillText(data.max.toFixed(range < 0.01 ? 4 : 2), 0, offset);
        ctx.textBaseline = 'bottom';
        ctx.fillText(data.min.toFixed(range < 0.01 ? 4 : 2), 0, offset + height);
        ctx.textBaseline = 'top';
        ctx.fillText(label, canvas.width / 2 - label.length * 2, offset);
    }

    function exportCpsMap() {
        const range = [fromChannelInput1.value, toChannelInput1.value];
        const energyRange = getEnergyRangeStr(range);
        const description = originalWaterfallData.baseSpectrum.name + ' CP2S: cps in range ' + energyRange;
        const data = exports.getRctrkData(
            description, 
            originalWaterfallData.deltas, 
            range, 
            undefined, 
            waterfallState.channelBinning
        );
        const filename = originalWaterfallData.baseSpectrum.name + '-' + energyRange;

        saveFile(filename + '-cps.rctrk', data, 'text/rctrk');
    }

    function exportComparisonMap() {
        const range = [fromChannelInput1.value, toChannelInput1.value];
        const compareRange = [fromChannelInput2.value, toChannelInput2.value];
        const energyRange = getEnergyRangeStr(range);
        const compareEnergyRange = getEnergyRangeStr(compareRange);
        const data = exports.getRctrkData(originalWaterfallData.baseSpectrum.name + 
            ' CP2S: cps comparison for ranges ' + energyRange + '/' + compareEnergyRange, 
            originalWaterfallData.deltas, range, compareRange, waterfallState.channelBinning
        );
        const filename = originalWaterfallData.baseSpectrum.name + '-' + energyRange + compareEnergyRange;

        saveFile(filename + '-cps-comparison.rctrk', data, 'text/rctrk');
    }

    function exportSpectrumRange() {
        const fromSpectrum = parseInt(fromSpectrumInput.value);
        const toSpectrum = parseInt(toSpectrumInput.value);
        if (isNaN(fromSpectrum) || isNaN(toSpectrum) || fromSpectrum > toSpectrum) {
            // TODO: implement UI validation
            throw new Error('invalid from or to spectrum index');
        }

        if (originalWaterfallData.channelBinning !== 1) {
            alert('Export to ' + originalWaterfallData.baseSpectrum.channelCount + ' channels due to channel binning applied by CLI.');
        }
        
        const combinedSpectrum = exports.combineSpectrums(
            originalWaterfallData.deltas, 
            fromSpectrum, 
            toSpectrum, 
            originalWaterfallData.baseSpectrum, 
            originalWaterfallData.filename
        );
        const spectrumText = exports.serializeSpectrum(combinedSpectrum);
        const filename = originalWaterfallData.baseSpectrum.name + '-[' + fromSpectrum + ', ' + toSpectrum + ']';

        saveFile(filename + '-combined.txt', spectrumText, 'text/plain');
    }

    function saveFile(filename, data, type) {
        const blob = new Blob([data], { type: type });
        const elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;
        document.body.appendChild(elem);
        elem.click();
        document.body.removeChild(elem);
    }

    function getEnergyRangeStr(range) {
        return '[' + common.channelToEnergy(range[0]).toFixed(0) + '-' + common.channelToEnergy(range[1]).toFixed(0) + ' keV]';
    }
})();
</script>
		<script>(function(){
    // mouse cursor render
    const wfContainer = document.getElementById('waterfall-container');
    const cpsContainer = document.getElementById('cps-container');
    const waterfallPlot = document.getElementById('waterfall-plot');
    const cpsPlot = document.getElementById('cps-plot');
    const wfHorizontalCursor = document.getElementById('horizontal-cursor');
    const wfVerticalCursor = document.getElementById('vertical-cursor');
    
    wfContainer.addEventListener('scroll', (e) => onWfContainerScroll(e));
    cpsContainer.addEventListener('scroll', (e) => onCpsContainerScroll(e));
    waterfallPlot.addEventListener('mouseleave', e => plotOnMouseLeave(e));
    waterfallPlot.addEventListener('mousemove', e => waterfallOnMouseMove(e));
    cpsPlot.addEventListener('mouseleave', e => plotOnMouseLeave(e));
    cpsPlot.addEventListener('mousemove', e => cpsOnMouseMove(e));

    function plotOnMouseLeave(e) {
        wfHorizontalCursor.style.display = 'none';
        wfVerticalCursor.style.display = 'none';

        waterfallPlot.setAttribute('title', '');
        cpsPlot.setAttribute('title', '');
    }

    function waterfallOnMouseMove(e) {
        wfHorizontalCursor.style.display = 'block';
        wfVerticalCursor.style.display = 'block';

        // channel cursor
        let offsetX = e.offsetX - constants.cursorOffset;
        if (offsetX < constants.timeAxisWidth) {
            offsetX = constants.timeAxisWidth;
        } else if (offsetX > constants.timeAxisWidth + waterfallData.baseSpectrum.channelCount - 1) {
            offsetX = constants.timeAxisWidth + waterfallData.baseSpectrum.channelCount - 1;
        }

        // spectrum cursor
        let offsetY = e.offsetY - constants.cursorOffset;
        if (offsetY < 0) {
            offsetY = 0;
        } else if (e.offsetY >= waterfallData.deltas.length) {
            offsetY = waterfallData.deltas.length - 1;
            offsetY = waterfallData.deltas.length - 1;
        }
        
        // tooltip
        const spectrumIndex = offsetY;
        const channelIndex = offsetX - constants.timeAxisWidth;
        const tooltipText = 'spectrum: ' + spectrumIndex * waterfallState.spectrumBinning * originalWaterfallData.spectrumBinning
            + '\n' + 'channel: ' + channelIndex
            + '\n' + 'energy: ' + common.channelToEnergy(channelIndex).toFixed(1) + ' keV'
            + '\n' + 'time: ' + common.timeToString(waterfallData.deltas[spectrumIndex].timestamp);
        waterfallPlot.setAttribute('title', tooltipText);

        // vertical line
        const wfContainerRect = wfContainer.getBoundingClientRect();
        wfVerticalCursor.style.left = offsetX + wfContainerRect.left - wfContainer.scrollLeft;
        wfVerticalCursor.style.height = wfContainerRect.height + 'px';

        // horizontal line
        const cpsContainerRect = cpsContainer.getBoundingClientRect();
        wfHorizontalCursor.style.top = offsetY + wfContainerRect.top - wfContainer.scrollTop;
        wfHorizontalCursor.style.left = wfContainerRect.left;
        wfHorizontalCursor.style.width = wfContainerRect.width + cpsContainerRect.width + 'px';
    }

    function cpsOnMouseMove(e) {
        wfHorizontalCursor.style.display = 'block';
        wfVerticalCursor.style.display = 'none';

        // spectrum cursor
        let offsetX = e.offsetX - constants.cursorOffset;
        if (offsetX < 0) {
            offsetX = 0;
        } else if (offsetX > waterfallData.deltas.length - 1) {
            offsetX = waterfallData.deltas.length - 1;
        }

        // tooltip
        const spectrumIndex = offsetX;
        const tooltipText = 'spectrum: ' + spectrumIndex * waterfallState.spectrumBinning * originalWaterfallData.spectrumBinning
            + '\n' + 'time: ' + common.timeToString(waterfallData.deltas[spectrumIndex].timestamp);
        cpsPlot.setAttribute('title', tooltipText);

        // horizontal line
        const wfContainerRect = wfContainer.getBoundingClientRect();
        const cpsContainerRect = cpsContainer.getBoundingClientRect();
        wfHorizontalCursor.style.top = offsetX + cpsContainerRect.top - cpsContainer.scrollTop;
        wfHorizontalCursor.style.left = wfContainerRect.left;
        wfHorizontalCursor.style.width = wfContainerRect.width + cpsContainerRect.width + 'px';
    }

    function onCpsContainerScroll(event) {
        if (wfContainer.scrollTop !== cpsContainer.scrollTop) {
            wfContainer.scrollTop = cpsContainer.scrollTop;
        }
    }

    function onWfContainerScroll(event) {
        if (cpsContainer.scrollTop !== wfContainer.scrollTop) {
            cpsContainer.scrollTop = wfContainer.scrollTop;
        }
    }
})();
</script>
		<script>(function(){
    // waterfall binning/average control
    const spectrumBinningInput = document.getElementById('spectrum-binning');
    const channelBinningInput = document.getElementById('channel-binning');
    const movingAverageInput = document.getElementById('moving-average');
    spectrumBinningInput.addEventListener('change', e => onSpectrumBinningChange(e.target.value));
    channelBinningInput.addEventListener('change', e => onChannelBinningChange(e.target.value));
    movingAverageInput.addEventListener('change', e => onMovingAverageChange(e.target.value));

    const linBtn = document.getElementById('lin');
    const sqrtBtn = document.getElementById('sqrt');
    const logBtn = document.getElementById('log');
    linBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));
    sqrtBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));
    logBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));

    const blurCheckbox = document.getElementById('blur-waterfall');
    blurCheckbox.addEventListener('change', (e) => onWaterfallBlurChange(e.target.checked));

    const subtractCheckbox = document.getElementById('subtract-base');
    subtractCheckbox.addEventListener('change', (e) => onWaterfallSubtractChange(e.target.checked));

    const maxCpsInput = document.getElementById('max-cps');
    maxCpsInput.addEventListener('change', (e) => onMaxCpsChange(e.target.value));
    
    window.binning = {
        resetWaterfallBinning: () => {
            spectrumBinningInput.value = 1;
            channelBinningInput.value = 1;
            waterfallState.channelBinning = 1;
            waterfallState.spectrumBinning = 1;
        },
        resetMovingAverage: () => {
            waterfallState.movingAverage = 0;
            movingAverageInput.value = 0;
        },
        applyBinningAndAverage: () => {
            waterfallData = exports.createWaterfallData(
                originalWaterfallData.baseSpectrum, 
                originalWaterfallData.deltas, 
                waterfallState.channelBinning, 
                waterfallState.spectrumBinning
            );

            applyMovingAverage();
        }
    }; 

    function onWaterfallScaleChange(value) {
        waterfallState.scale = value;
        waterfall.renderWaterfallImage();
    }

    function onWaterfallBlurChange(value) {
        waterfallState.blur = value;
        waterfall.renderWaterfallImage();
    }

    function onWaterfallSubtractChange(value) {
        waterfallState.subtractBase = value;
        waterfall.renderWaterfallImage();
        cps.renderCps();
    }

    function onSpectrumBinningChange(value) {
        const newBin = parseInt(value);
        waterfallState.spectrumBinning = newBin;

        binning.applyBinningAndAverage();
        waterfall.renderWaterfallImage();
        cps.renderCps();
    }

    function onChannelBinningChange(value) {
        const newBin = parseInt(value);
        const prevBin = waterfallState.channelBinning;
        waterfallState.channelBinning = newBin;

        binning.applyBinningAndAverage();
        waterfall.renderWaterfallImage();

        // TODO: refactor duplicated code
        const fromChannelInput1 = document.getElementById('from-channel-1');
        const toChannelInput1 = document.getElementById('to-channel-1');
        const fromChannelInput2 = document.getElementById('from-channel-2');
        const toChannelInput2 = document.getElementById('to-channel-2');

        updateInputChannelValue(fromChannelInput1, newBin, prevBin);
        updateInputChannelValue(toChannelInput1, newBin, prevBin);
        updateInputChannelValue(fromChannelInput2, newBin, prevBin);
        updateInputChannelValue(toChannelInput2, newBin, prevBin);

        cps.renderCps();
    }

    function onMovingAverageChange(value) {
        const windowSize = parseInt(value);
        if (windowSize === waterfallState.movingAverage) {
            return;
        }
        waterfallState.movingAverage = windowSize;

        binning.applyBinningAndAverage();
        waterfall.renderWaterfallImage();
        cps.renderCps();
    }

    function onMaxCpsChange(value) {
        waterfallState.maxCpsPercent = parseInt(value);
        waterfall.renderWaterfallImage();
    }
    
    function updateInputChannelValue(input, newBin, prevBin) {
        const prevVal = parseInt(input.value);

        if (!isNaN(prevVal)) {
            let newVal = Math.round((prevVal / newBin) * prevBin);
            if (newVal < 0) {
                newVal = 0;
            }
            if (newVal > waterfallData.baseSpectrum.channelCount - 1) {
                newVal = waterfallData.baseSpectrum.channelCount - 1;
            }
            input.value = newVal;
        }
    }

    function applyMovingAverage() {
        windowSize = waterfallState.movingAverage;
        // horizontal average
        let avgDeltas = [];
        for (let i = 0; i < waterfallData.deltas.length; i++) {
            const avgDelta = {
                ...waterfallData.deltas[i],
                channels: []
            };
            for (let j = 0; j < waterfallData.deltas[i].channels.length; j++) {
                avgDelta.channels.push(waterfallData.deltas[i].channels[j]);
                let appliedSize = 0;
                for (let k = j - windowSize / 2; k <= j + windowSize / 2; k++) {
                    if (k < 0 || k === j) {
                        continue;
                    }
                    if (k >= waterfallData.deltas[i].channels.length) {
                        break;
                    }
                    avgDelta.channels[j] += waterfallData.deltas[i].channels[k];
                    appliedSize++;
                }
                avgDelta.channels[j] /= appliedSize + 1;
            }

            avgDeltas.push(avgDelta);
        }
        waterfallData.deltas = avgDeltas;

        // vertical average
        avgDeltas = [];
        for (let i = 0; i < waterfallData.deltas.length; i++) {
            const avgDelta = {
                ...waterfallData.deltas[i],
                channels: [...waterfallData.deltas[i].channels]
            };
            for (let j = 0; j < avgDelta.channels.length; j++) {
                let appliedSize = 0;
                for (let k = i - windowSize / 2; k <= i + windowSize / 2; k++) {
                    if (k < 0 || k === i) {
                        continue;
                    }

                    if (k >= waterfallData.deltas.length) {
                        break;
                    }

                    avgDelta.channels[j] += waterfallData.deltas[k].channels[j] * (waterfallData.deltas[i].duration / waterfallData.deltas[k].duration);
                    appliedSize++;
                }

                avgDelta.channels[j] /= appliedSize + 1;
            }

            avgDeltas.push(avgDelta);
        }

        waterfallData.deltas = avgDeltas;
    }
})();
</script>
		<script>(function(){
    // startup - check if we have to run with nodejs prepared data or user loads it in browser
    const uploadControl = document.getElementById('upload-control');
    const infoContainer = document.getElementById('file-info-container');
    const infoSpan = document.getElementById('file-info');
    const overlay = document.getElementById('blocking-overlay');
    const fileInput = document.getElementById('file-input');

    fileInput.addEventListener('change', (e) => onFileChange(e.target));

    if (window.originalWaterfallData === 'waterfall-data-placeholder') {
        uploadControl.style.display = 'block';
        infoContainer.style.display = 'none';
    } else {
        uploadControl.style.display = 'none';
        overlay.style.display = 'none';
        infoContainer.style.display = 'block';
        infoSpan.innerText = 'Atomspectra file: ' + originalWaterfallData.filename + '; already applied binning - '
            + 'spectrum: ' + originalWaterfallData.spectrumBinning + ', channel: ' + originalWaterfallData.channelBinning;
        
        window.waterfallData = { ...originalWaterfallData };
        waterfall.renderWaterfallImage();
        cps.initCpsControls();
        cps.renderCps();
    }

    function onFileChange(input) {
        const file = input.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            overlay.style.display = 'none';
            const fileText = e.target.result;
            const baseSpectrum = exports.deserializeSpectrum(fileText);
            const deltaInfo = exports.deserializeDeltas(fileText, baseSpectrum);
            const deltas = deltaInfo.deltas;

            window.originalWaterfallData = exports.createWaterfallData(baseSpectrum, deltas, 1, 1, file.name);
            window.waterfallData = { ...originalWaterfallData };

            binning.resetMovingAverage();
            binning.resetWaterfallBinning();
            waterfallState.channelBinning = 8;
            document.getElementById('channel-binning').value = waterfallState.channelBinning;

            binning.applyBinningAndAverage();
            cps.initCpsControls();
            waterfall.renderWaterfallImage();
            cps.renderCps();
        };

        reader.readAsText(file);
    }
})();</script>
	</body>
</html>