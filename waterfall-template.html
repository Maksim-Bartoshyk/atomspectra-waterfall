<html>
	<head>
		<style>
			body {
				background: black;
				color: lightgray;
				padding: 8px;
			}
			.scale-switch, .cps-control {
				width: 100%;
				margin: 4px 0;
			}
			.plot-container {
				position: relative;
				width: fit-content;
			}
			.plot {
				border: 1px dashed #444;
			}
			.horizontal-cursor, .vertical-cursor {
				display: none;
				position: absolute;
			}
			.horizontal-cursor {
				border-top: 1px dotted #777;
				height: 0;
				right: 0;
				width: calc(100% - 150px);
			}
			.vertical-cursor {
				border-left: 1px dotted #777;
				height: 100%;
				top: 0;
				width: 0;
			}
			.cps-left-column {
				display: inline-block;
				width: 250px;
			}
		</style>
		<script>
			window.originalWaterfallData = {waterfall_data};
			window.waterfallData = { ...originalWaterfallData };
		</script>
	</head>
	<body>
		<div class="scale-switch">
			<input type="radio" id="lin" name="scale" value="lin" onchange="onWaterfallScaleChange(this.value)">
			<label for="lin">LIN</label>
			<input type="radio" id="sqrt" name="scale" value="sqrt" checked onchange="onWaterfallScaleChange(this.value)">
			<label for="sqrt">SQRT</label>
			<input type="radio" id="log" name="scale" value="log" onchange="onWaterfallScaleChange(this.value)">
			<label for="log">LOG</label>
			<br/>
			<label for="spectrum-binning">Spectrum binning:</label>
			<select name="spectrum-binning" id="spectrum-binning" onchange="onSpectrumBinningChange(this.value)">
				<option value="1">1</option>
				<option value="2">2</option>
				<option value="3">3</option>
				<option value="4">4</option>
				<option value="5">5</option>
				<option value="6">6</option>
				<option value="7">7</option>
				<option value="8">8</option>
				<option value="9">9</option>
				<option value="10">10</option>
			</select>
			<label for="channel-binning">Channel binning:</label>
			<select name="channel-binning" id="channel-binning" onchange="onChannelBinningChange(this.value)">
				<option value="1">1</option>
				<option value="2">2</option>
				<option value="4">4</option>
				<option value="8">8</option>
				<option value="16">16</option>
				<option value="32">32</option>
			</select>
		</div>
		<div class="plot-container">
			<canvas id="waterfall-plot" class="plot"></canvas>
			<div id="horizontal-cursor" class="horizontal-cursor"></div>
			<div id="vertical-cursor" class="vertical-cursor"></div>
		</div>
		<div class="cps-control">
			<button class="cps-left-column" onclick="renderCps()">CPS trend in channel range:</button> 
			<input id="from-channel-1" type="number"/>-<input id="to-channel-1" type="number"/>
			<input id="dotted-trend" name="dotted-trend" type="checkbox"/>
			<label for="dotted-trend">Dotted</label>
			<br />
			<div class="cps-left-column">
				<input id="cps-comparison" name="cps-comparison" type="checkbox"/>
				<label for="cps-comparison">Compare to CPS in channel range:</label>
			</div>
			<input id="from-channel-2" type="number"/>-<input id="to-channel-2" type="number"/>
		</div>
		<div class="plot-container">
			<canvas id="cps-plot" class="plot"></canvas>
			<div id="cps-vertical-cursor" class="vertical-cursor"></div>
		</div>
		<script>
			window.constants = {
				timestampWidth: 150, // note: the same in css
				timestampHeight: 20,
				timestampTickWidth: 10,
				channelAxisHeight: 32,
				channelAxisTickHeight: 4,
				backgroundColor: 'black',
				textColor: 'lightgray',
				lineColor: 'lightgray',
				separatorLineColor: '#777',
				dotColor: 'white',
				cpsPlotHeight: 200,
				cpsExtendRange: 0.1
			};
			window.waterfallState = {
				scale: 'sqrt',
				spectrumBinning: 1,
				channelBinning: 1
			}
		</script>
		<script>
			// waterfall plot render
			function renderWaterfallImage() {
				const canvas = document.getElementById('waterfall-plot');
				canvas.width = waterfallData.channelCount + constants.timestampWidth;
				canvas.height = waterfallData.spectrumsCount + constants.channelAxisHeight;

				const ironPalette = [
					"#00000a","#000014","#00001e","#000025","#00002a","#00002e","#000032","#000036",
					"#00003a","#00003e","#000042","#000046","#00004a","#00004f","#000052","#010055",
					"#010057","#020059","#02005c","#03005e","#040061","#040063","#050065","#060067",
					"#070069","#08006b","#09006e","#0a0070","#0b0073","#0c0074","#0d0075","#0d0076",
					"#0e0077","#100078","#120079","#13007b","#15007c","#17007d","#19007e","#1b0080",
					"#1c0081","#1e0083","#200084","#220085","#240086","#260087","#280089","#2a0089",
					"#2c008a","#2e008b","#30008c","#32008d","#34008e","#36008e","#38008f","#390090",
					"#3b0091","#3c0092","#3e0093","#3f0093","#410094","#420095","#440095","#450096",
					"#470096","#490096","#4a0096","#4c0097","#4e0097","#4f0097","#510097","#520098",
					"#540098","#560098","#580099","#5a0099","#5c0099","#5d009a","#5f009a","#61009b",
					"#63009b","#64009b","#66009b","#68009b","#6a009b","#6c009c","#6d009c","#6f009c",
					"#70009c","#71009d","#73009d","#75009d","#77009d","#78009d","#7a009d","#7c009d",
					"#7e009d","#7f009d","#81009d","#83009d","#84009d","#86009d","#87009d","#89009d",
					"#8a009d","#8b009d","#8d009d","#8f009c","#91009c","#93009c","#95009c","#96009b",
					"#98009b","#99009b","#9b009b","#9c009b","#9d009b","#9f009b","#a0009b","#a2009b",
					"#a3009b","#a4009b","#a6009a","#a7009a","#a8009a","#a90099","#aa0099","#ab0099",
					"#ad0099","#ae0198","#af0198","#b00198","#b00198","#b10197","#b20197","#b30196",
					"#b40296","#b50295","#b60295","#b70395","#b80395","#b90495","#ba0495","#ba0494",
					"#bb0593","#bc0593","#bd0593","#be0692","#bf0692","#bf0692","#c00791","#c00791",
					"#c10890","#c10990","#c20a8f","#c30a8e","#c30b8e","#c40c8d","#c50c8c","#c60d8b",
					"#c60e8a","#c70f89","#c81088","#c91187","#ca1286","#ca1385","#cb1385","#cb1484",
					"#cc1582","#cd1681","#ce1780","#ce187e","#cf187c","#cf197b","#d01a79","#d11b78",
					"#d11c76","#d21c75","#d21d74","#d31e72","#d32071","#d4216f","#d4226e","#d5236b",
					"#d52469","#d62567","#d72665","#d82764","#d82862","#d92a60","#da2b5e","#da2c5c",
					"#db2e5a","#db2f57","#dc2f54","#dd3051","#dd314e","#de324a","#de3347","#df3444",
					"#df3541","#df363d","#e0373a","#e03837","#e03933","#e13a30","#e23b2d","#e23c2a",
					"#e33d26","#e33e23","#e43f20","#e4411d","#e4421c","#e5431b","#e54419","#e54518",
					"#e64616","#e74715","#e74814","#e74913","#e84a12","#e84c10","#e84c0f","#e94d0e",
					"#e94d0d","#ea4e0c","#ea4f0c","#eb500b","#eb510a","#eb520a","#eb5309","#ec5409",
					"#ec5608","#ec5708","#ec5808","#ed5907","#ed5a07","#ed5b06","#ee5c06","#ee5c05",
					"#ee5d05","#ee5e05","#ef5f04","#ef6004","#ef6104","#ef6204","#f06303","#f06403",
					"#f06503","#f16603","#f16603","#f16703","#f16803","#f16902","#f16a02","#f16b02",
					"#f16b02","#f26c01","#f26d01","#f26e01","#f36f01","#f37001","#f37101","#f37201",
					"#f47300","#f47400","#f47500","#f47600","#f47700","#f47800","#f47a00","#f57b00",
					"#f57c00","#f57e00","#f57f00","#f68000","#f68100","#f68200","#f78300","#f78400",
					"#f78500","#f78600","#f88700","#f88800","#f88800","#f88900","#f88a00","#f88b00",
					"#f88c00","#f98d00","#f98d00","#f98e00","#f98f00","#f99000","#f99100","#f99200",
					"#f99300","#fa9400","#fa9500","#fa9600","#fb9800","#fb9900","#fb9a00","#fb9c00",
					"#fc9d00","#fc9f00","#fca000","#fca100","#fda200","#fda300","#fda400","#fda600",
					"#fda700","#fda800","#fdaa00","#fdab00","#fdac00","#fdad00","#fdae00","#feaf00",
					"#feb000","#feb100","#feb200","#feb300","#feb400","#feb500","#feb600","#feb800",
					"#feb900","#feb900","#feba00","#febb00","#febc00","#febd00","#febe00","#fec000",
					"#fec100","#fec200","#fec300","#fec400","#fec500","#fec600","#fec700","#fec800",
					"#fec901","#feca01","#feca01","#fecb01","#fecc02","#fecd02","#fece03","#fecf04",
					"#fecf04","#fed005","#fed106","#fed308","#fed409","#fed50a","#fed60a","#fed70b",
					"#fed80c","#fed90d","#ffda0e","#ffda0e","#ffdb10","#ffdc12","#ffdc14","#ffdd16",
					"#ffde19","#ffde1b","#ffdf1e","#ffe020","#ffe122","#ffe224","#ffe226","#ffe328",
					"#ffe42b","#ffe42e","#ffe531","#ffe635","#ffe638","#ffe73c","#ffe83f","#ffe943",
					"#ffea46","#ffeb49","#ffeb4d","#ffec50","#ffed54","#ffee57","#ffee5b","#ffee5f",
					"#ffef63","#ffef67","#fff06a","#fff06e","#fff172","#fff177","#fff17b","#fff280",
					"#fff285","#fff28a","#fff38e","#fff492","#fff496","#fff49a","#fff59e","#fff5a2",
					"#fff5a6","#fff6aa","#fff6af","#fff7b3","#fff7b6","#fff8ba","#fff8bd","#fff8c1",
					"#fff8c4","#fff9c7","#fff9ca","#fff9cd","#fffad1","#fffad4","#fffbd8","#fffcdb",
					"#fffcdf","#fffde2","#fffde5","#fffde8","#fffeeb","#fffeee","#fffef1","#fffef4",
					"#fffff6"];
				const ctx = canvas.getContext("2d");
				ctx.fillStyle = constants.backgroundColor;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				let maxCps = 0;
				waterfallData.spectrums.forEach((spectrum, spectrumIndex) => {
					spectrum.forEach(channelValue => {
						if (!channelValue) {
							return;
						}

						const cps = channelValue / waterfallData.durations[spectrumIndex];
						maxCps = Math.max(maxCps, cps);
					});
				});

				// waterfall render
				waterfallData.spectrums.forEach((spectrum, spectrumIndex) => {
					spectrum.forEach((channelValue, channelIndex) => {
						if (!channelValue) {
							return;
						}

						const cps = channelValue / waterfallData.durations[spectrumIndex];
						const linearColorIndex = Math.round((cps / maxCps) * (ironPalette.length - 1));
						let colorIndex;

						switch (waterfallState.scale) {
							case 'log':
								colorIndex = Math.round((Math.log(linearColorIndex + 2) / Math.log(ironPalette.length)) * (ironPalette.length - 1));
								break;
							case 'sqrt':
								colorIndex = Math.round((Math.sqrt(linearColorIndex + 2) / Math.sqrt(ironPalette.length)) * (ironPalette.length - 1));
								break;
							default:
								colorIndex = linearColorIndex;
						}

						ctx.fillStyle = ironPalette[colorIndex];
						ctx.fillRect(channelIndex + constants.timestampWidth, spectrumIndex, 1, 1);
					});
				});

				// time axis
				for (let tsIndex = 0; tsIndex < waterfallData.timestamps.length; tsIndex += constants.timestampHeight) {
					timestamp = waterfallData.timestamps[tsIndex];
					ctx.textBaseline = 'top';
					ctx.fillStyle = constants.textColor;
					const utcISO = new Date(timestamp).toISOString();
					let label = utcISO.split('T').join(' ').split('.')[0] + ' UTC';
					if (tsIndex % 100 === 0) {
						label += ': ' + tsIndex;
					}
					ctx.fillText(label, 0, tsIndex);

					// label tick
					const tickWidth = tsIndex % 100 === 0
						? constants.timestampTickWidth
						: constants.timestampTickWidth / 2;
					for (let x = constants.timestampWidth - tickWidth; x < constants.timestampWidth; x++) {
						ctx.fillRect(x, tsIndex, 1, 1);
					}
				}

				// calculate energy for each channel
				const allEnergies = [];
				for (let i = 0; i < waterfallData.channelCount; i++) {
					let energy = 0;
					for (let order = 0; order < waterfallData.calibration.length; order++) {
						energy += Math.pow(i, order) * waterfallData.calibration[order];
					}
					allEnergies.push(energy);
				}

				// calculate channels for 0, 100, 200, 300... enegries 
				const renderEnergies = {};
				for (let energy = 0, channel = 0; energy < allEnergies[allEnergies.length - 1]; energy += 100) {
					while (allEnergies[channel] < energy) {
						channel++;
					}
					renderEnergies[channel] = energy;
				}

				// energy axis render
				const energyAxisBaseline = waterfallData.spectrumsCount;
				const channelAxisBaseline = waterfallData.spectrumsCount + constants.channelAxisHeight / 2;
				let kevRendered = false;
				for (let x = constants.timestampWidth; x < canvas.width; x++) {
					const channelNumber = x - constants.timestampWidth;
					const energy = renderEnergies[channelNumber];

					if (energy != undefined && energy % 500 === 0) {
						ctx.textBaseline = 'top';
						ctx.fillStyle = constants.textColor;
						const label = kevRendered ? energy.toString() : energy + ' keV';
						ctx.fillText(label, x, energyAxisBaseline + constants.channelAxisTickHeight);
						kevRendered = true;
					}

					if (energy != undefined && energy % 100 === 0) {
						const tickHeight = energy % 500 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
						for (let y = energyAxisBaseline; y < energyAxisBaseline + tickHeight; y++) {
							ctx.fillRect(x, y, 1, 1);
						}
					}

					if (channelNumber % 100 === 0) {
						ctx.textBaseline = 'top';
						ctx.fillStyle = constants.textColor;
						const label = channelNumber === 0 ? channelNumber + ' channel' : channelNumber.toString();
						ctx.fillText(label, x, channelAxisBaseline + constants.channelAxisTickHeight);
					}

					if (channelNumber % 10 === 0) {
						const tickHeight = channelNumber % 50 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
						for (let y = channelAxisBaseline; y < channelAxisBaseline + tickHeight; y++) {
							ctx.fillRect(x, y, 1, 1);
						}
					}
				}
			}

			renderWaterfallImage('sqrt');
		</script>
		<script>
			// cps plot render
			const fromChannelInput1 = document.getElementById('from-channel-1');
			const toChannelInput1 = document.getElementById('to-channel-1');
			const dottedCheckbox = document.getElementById('dotted-trend');
			const fromChannelInput2 = document.getElementById('from-channel-2');
			const toChannelInput2 = document.getElementById('to-channel-2');
			const compareCheckbox = document.getElementById('cps-comparison');
			fromChannelInput1.value = 0;
			toChannelInput1.value = waterfallData.channelCount - 1;
			fromChannelInput2.value = 0;
			toChannelInput2.value = waterfallData.channelCount - 1;
			renderCps();

			function getCountsInRange(from, to) {
				const countsInRange = {};
				waterfallData.spectrums.forEach((spectrum, spectrumIndex) => {
					for (let ci = from; ci <= to; ci++) {
						if (countsInRange[spectrumIndex] === undefined) {
							countsInRange[spectrumIndex] = spectrum[ci];
						} else {
							countsInRange[spectrumIndex] += spectrum[ci];
						}
					}
				});
				
				return countsInRange;
			}
			
			function countsToCps(countsInRange) {
				const cpsInRange = {};
				Object.keys(countsInRange).forEach(index => {
					cpsInRange[index] = countsInRange[index] / waterfallData.durations[index];
				});
				
				return cpsInRange;
			}
			
			function getRenderData(valuesInRange) {
				let max = 0;
				let min = Infinity;
				for (let i = 0; i < waterfallData.spectrumsCount; i++) {
					if (valuesInRange[i] === undefined) {
						continue;
					}

					max = Math.max(max, valuesInRange[i]);
					min = Math.min(min, valuesInRange[i]);
				}

				if (max === 0 && min === 0) {
					max = 1;
					min = -1;
				}
				const range = max - min;
				max += constants.cpsExtendRange * (range === 0 ? max : range);
				min -= constants.cpsExtendRange * (range === 0 ? max : range);
			
				return {
					values: valuesInRange,
					max: max,
					min: min
				}
			}

			function renderCps() {
				const cpsCanvas = document.getElementById('cps-plot');
				cpsCanvas.width = waterfallData.spectrumsCount;
				cpsCanvas.height = constants.cpsPlotHeight;
			
				const fromChannel1 = parseInt(fromChannelInput1.value);
				const toChannel1 = parseInt(toChannelInput1.value);
				if (isNaN(fromChannel1) || isNaN(toChannel1) || fromChannel1 > toChannel1) {
					renderCpsData(cpsCanvas, 0, 0, {});
					return;
				}
				
				const fromChannel2 = parseInt(fromChannelInput2.value);
				const toChannel2 = parseInt(toChannelInput2.value);
				if (compareCheckbox.checked && (isNaN(fromChannel2) || isNaN(toChannel2) || fromChannel2 > toChannel2)) {
					renderCpsData(cpsCanvas, 0, 0, {});
					return;
				}

				if (compareCheckbox.checked) {
					const countsInRange1 = getCountsInRange(fromChannel1, toChannel1);
					const cpsInRange1 = countsToCps(countsInRange1);
					const countsInRange2 = getCountsInRange(fromChannel2, toChannel2);
					const cpsInRange2 = countsToCps(countsInRange2);
					const ratio = {};
					for (let i = 0; i < waterfallData.spectrumsCount; i++) {
						if (cpsInRange1[i] !== undefined && cpsInRange2[i] > 0) {
							ratio[i] = cpsInRange1[i] / cpsInRange2[i];
						}
					}

					const plotHeight = constants.cpsPlotHeight;
					cpsCanvas.height = plotHeight * 3;
					renderCpsData(cpsCanvas, getRenderData(cpsInRange1), 0, plotHeight, 'range 1 cps');
					renderCpsData(cpsCanvas, getRenderData(cpsInRange2), plotHeight, plotHeight, 'range 2 cps');
					renderCpsData(cpsCanvas, getRenderData(ratio), plotHeight * 2, plotHeight, 'range 1 / range 2');
				} else {
					const countsInRange1 = getCountsInRange(fromChannel1, toChannel1);
					const cpsInRange1 = countsToCps(countsInRange1);
					const renderData = getRenderData(cpsInRange1);

					renderCpsData(cpsCanvas, renderData, 0, cpsCanvas.height, 'range 1 cps');
				}
			}

			function renderCpsData(canvas, data, offset, height, label) {
				const range = data.max - data.min;

				const ctx = canvas.getContext("2d");
				ctx.fillStyle = constants.backgroundColor;
				ctx.fillRect(0, offset, canvas.width, height);

				if (dottedCheckbox.checked) {
					// points
					ctx.fillStyle = constants.dotColor;
					for (let x = 0; x < waterfallData.spectrumsCount; x++) {
						if (data.values[x] === undefined) {
							continue;
						}

						const y = height - ((data.values[x] - data.min) / range) * height + offset;
						ctx.fillRect(x, y, 1, 1);
					}
				} else {
					// lines
					ctx.beginPath();
					ctx.lineWidth = 1;
					ctx.setLineDash([1, 0]);
					ctx.strokeStyle = constants.lineColor;
					let firstMove = true;
					for (let x = 0; x < waterfallData.spectrumsCount; x++) {
						if (data.values[x] === undefined) {
							continue;
						}

						const y = height - ((data.values[x] - data.min) / range) * height + offset;

						if (firstMove) {
							ctx.moveTo(x, y);
							firstMove = false;
						} else {
							ctx.lineTo(x, y);
							ctx.moveTo(x, y);
						}
					}
					ctx.stroke();
				}

				// separator line
				if (offset > 0) {
					ctx.beginPath();
					ctx.lineWidth = 1;
					ctx.setLineDash([2, 2]);
					ctx.strokeStyle = constants.separatorLineColor;
					ctx.moveTo(0, offset - 0.5);
					ctx.lineTo(canvas.width, offset - 0.5);
					ctx.stroke();
				}

				// labels
				ctx.fillStyle = constants.textColor;
				ctx.textBaseline = 'top';
				ctx.fillText(data.max.toFixed(range < 0.01 ? 4 : 2), 0, offset);
				ctx.textBaseline = 'bottom';
				ctx.fillText(data.min.toFixed(range < 0.01 ? 4 : 2), 0, offset + height);
				ctx.textBaseline = 'top';
				ctx.fillText(label, canvas.width / 2 - label.length * 2, offset);
			}
		</script>
		<script>
			// mouse cursor render
			const waterfallPlot = document.getElementById('waterfall-plot');
			const cpsPlot = document.getElementById('cps-plot');
			const horizontal = document.getElementById('horizontal-cursor');
			const vertical = document.getElementById('vertical-cursor');
			const cpsVertical = document.getElementById('cps-vertical-cursor')
			waterfallPlot.parentElement.addEventListener('mouseenter', e => waterfallOnEnter(e));
			waterfallPlot.parentElement.addEventListener('mouseleave', e => plotOnLeave(e));
			waterfallPlot.parentElement.addEventListener('mousemove', e => waterfallOnMove(e));
			cpsPlot.parentElement.addEventListener('mouseenter', e => cpsOnEnter(e));
			cpsPlot.parentElement.addEventListener('mouseleave', e => plotOnLeave(e));
			cpsPlot.parentElement.addEventListener('mousemove', e => cpsOnMove(e));
			horizontal.addEventListener('mousemove', e => onHorizontalWfMove(e, true));
			vertical.addEventListener('mousemove', e => onVerticalWfMove(e));

			function waterfallOnEnter() {
				horizontal.style.display = 'block';
				vertical.style.display = 'block';
				cpsVertical.style.display = 'block';
			}

			function cpsOnEnter() {
				horizontal.style.display = 'block';
				vertical.style.display = 'none';
				cpsVertical.style.display = 'block';
			}

			function plotOnLeave(e) {
				if (isCursor(e.target)) {
					return;
				}

				horizontal.style.display = 'none';
				vertical.style.display = 'none';
				cpsVertical.style.display = 'none';
			}

			function waterfallOnMove(e) {
				if (isCursor(e.target)) {
					return;
				}

				onHorizontalWfMove(e, false);
				onVerticalWfMove(e);
			}

			function cpsOnMove(e) {
				if (isCursor(e.target)) {
					return;
				}

				// spectrum index
				let offsetX = e.offsetX;
				if (offsetX > 0) {
					offsetX--;
				}

				horizontal.style.top = offsetX;
				cpsVertical.style.left = offsetX;
			}

			function onHorizontalWfMove(e, cursorDivOffset) {
				// channel index
				let offsetX = cursorDivOffset
					? e.offsetX + constants.timestampWidth
					: e.offsetX;
				offsetX--;

				if (offsetX < constants.timestampWidth) {
					vertical.style.left = constants.timestampWidth;
				} else {
					vertical.style.left = offsetX;
				}
			}

			function onVerticalWfMove(e) {
				// spectrum index
				let offsetY = e.offsetY;
				if (offsetY > 0) {
					offsetY--;
				}

				if (e.offsetY > waterfallData.spectrumsCount) {
					horizontal.style.top = waterfallData.spectrumsCount;
					cpsVertical.style.left = waterfallData.spectrumsCount;
				} else {
					horizontal.style.top = offsetY;
					cpsVertical.style.left = offsetY;
				}
			}

			function isCursor(target) {
				return target === horizontal || target === vertical || target === cpsVertical;
			}
		</script>
		<script>
			// waterfall control
			function onWaterfallScaleChange(value) {
				waterfallState.scale = value;
				renderWaterfallImage();
			}

			function onSpectrumBinningChange(value) {
				const newBin = parseInt(value);
				waterfallState.spectrumBinning = newBin;

				applyBinning();
				renderWaterfallImage();
				renderCps();
			}

			function onChannelBinningChange(value) {
				const newBin = parseInt(value);
				const prevBin = waterfallState.channelBinning;
				waterfallState.channelBinning = newBin;

				applyBinning();
				renderWaterfallImage();

				// TODO: refactor duplicated code
				const fromChannelInput1 = document.getElementById('from-channel-1');
				const toChannelInput1 = document.getElementById('to-channel-1');
				const fromChannelInput2 = document.getElementById('from-channel-2');
				const toChannelInput2 = document.getElementById('to-channel-2');

				updateInputChannelValue(fromChannelInput1, newBin, prevBin);
				updateInputChannelValue(toChannelInput1, newBin, prevBin);
				updateInputChannelValue(fromChannelInput2, newBin, prevBin);
				updateInputChannelValue(toChannelInput2, newBin, prevBin);

				renderCps();
			}
			
			function updateInputChannelValue(input, newBin, prevBin) {
				
				const prevVal = parseInt(input.value);
				if (!isNaN(prevVal)) {
					let newVal = Math.round((prevVal / newBin) * prevBin);
					if (newVal < 0) {
						newVal = 0;
					}
					if (newVal > waterfallData.channelCount - 1) {
						newVal = waterfallData.channelCount - 1;
					}
					input.value = newVal;
				}
			}

			function applyBinning() {
				// spectrums
				waterfallData.spectrums = [];
				waterfallData.timestamps = [];
				waterfallData.durations = [];
				for (let i = 0; i < originalWaterfallData.spectrums.length; i += waterfallState.spectrumBinning) {
					const summSpectrum = [...originalWaterfallData.spectrums[i]];
					const summTimestamp = originalWaterfallData.timestamps[i];
					let summDuration = originalWaterfallData.durations[i];
					for (let j = 1; j < waterfallState.spectrumBinning && (i + j) < originalWaterfallData.spectrums.length; j++) {
						for (let k = 0; k < summSpectrum.length; k++) {
							summSpectrum[k] += originalWaterfallData.spectrums[i + j][k];
						}

						summDuration += originalWaterfallData.durations[i + j];
					}

					waterfallData.spectrums.push(summSpectrum);
					waterfallData.durations.push(summDuration);
					waterfallData.timestamps.push(summTimestamp);
				}
				waterfallData.spectrumsCount = waterfallData.spectrums.length;

				// channels
				for (let i = 0; i < waterfallData.spectrums.length; i++) {
					waterfallData.spectrums[i] = reduceChannelCount(waterfallData.spectrums[i], waterfallState.channelBinning);
				}
				waterfallData.channelCount = waterfallData.spectrums[0].length;

				// calibration
				waterfallData.calibration = [];
				for (let i = 0; i < originalWaterfallData.calibration.length; i++) {
					waterfallData.calibration.push(Math.pow(waterfallState.channelBinning, i) * originalWaterfallData.calibration[i]);
				}
			}

			function reduceChannelCount(channels, factor) {
				if (factor < 1) {
					throw new Error('invalid factor: ' + factor);
				}

				if (!channels || !channels.length) {
					throw new Error('no channels provided');
				}

				let reduced = [];
				for (let i = 0; i < channels.length; i += factor) {
					let summ = 0;
					for (let j = 0; j < factor && (i + j) < channels.length; j++) {
						summ += channels[i + j];
					}

					reduced.push(summ);
				}

				return reduced;
			}
		</script>
	</body>
</html>