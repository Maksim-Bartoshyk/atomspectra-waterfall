(function () {
  // TODO: split into separate files
  // waterfall binning/average control
  const spectrumBinningInput = document.getElementById('spectrum-binning');
  const channelBinningInput = document.getElementById('channel-binning');
  const movingAverageVerticalInput = document.getElementById('moving-average-vertical');
  const movingAverageHorizontalInput = document.getElementById('moving-average-horizontal');
  spectrumBinningInput.addEventListener('change', e => onSpectrumBinningChange(e.target.value));
  channelBinningInput.addEventListener('change', e => onChannelBinningChange(e.target.value));
  movingAverageVerticalInput.addEventListener('change', e => onVerticalMovingAverageChange(e.target.value));
  movingAverageHorizontalInput.addEventListener('change', e => onHorizontalMovingAverageChange(e.target.value));
  // end

  // scale control
  const linBtn = document.getElementById('lin');
  const sqrtBtn = document.getElementById('sqrt');
  const logBtn = document.getElementById('log');
  linBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));
  sqrtBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));
  logBtn.addEventListener('change', (e) => onWaterfallScaleChange(e.target.value));
  // end

//misc
consttimezoneInput=document.getElementById('timezone');
constsubtractCheckbox=document.getElementById('subtract-base');
constsubtractLabel=document.getElementById('subtract-base-label');
timezoneInput.addEventListener('change',(e)=>onTimezoneChange(e.target.value));
subtractCheckbox.addEventListener('change',(e)=>onWaterfallSubtractChange(e.target.checked));
//end

//palette
constblurCheckbox=document.getElementById('blur-waterfall');
constmaxCpsInput=document.getElementById('max-cps');
constminCpsInput=document.getElementById('min-cps');
constpalette=document.getElementById('palette');
maxCpsInput.addEventListener('change',(e)=>onMaxCpsChange(e.target.value));
minCpsInput.addEventListener('change',(e)=>onMinCpsChange(e.target.value));
palette.addEventListener('change',(e)=>onWaterfallPaletteChange(palette.value));
blurCheckbox.addEventListener('change',(e)=>onWaterfallBlurChange(e.target.checked));
//end

//bottomsection(cpsrelated)
constfromChannelInput1=document.getElementById('from-channel-1');
consttoChannelInput1=document.getElementById('to-channel-1');
constpreviewCheckbox=document.getElementById('preview-enabled');
constfromChannelInput2=document.getElementById('from-channel-2');
consttoChannelInput2=document.getElementById('to-channel-2');
constfromSpectrumInput=document.getElementById('from-spectrum');
consttoSpectrumInput=document.getElementById('to-spectrum');
constcpsRatioCheckbox=document.getElementById('cps-ratio');
constcpsCsvExportCheckbox=document.getElementById('cps-csv-export');
constcpsToMapButton=document.getElementById('export-cps-map');
constcpsBinAvgToMapButton=document.getElementById('export-bin-avg-cps-map');
constcpsRatioToMapButton=document.getElementById('export-ratio-map');
constcpsRatioBinAvgToMapButton=document.getElementById('export-bin-avg-ratio-map');
constspgToSpectrumFileButton=document.getElementById('spg-range-to-file');
constspgAsBaseButton=document.getElementById('spg-range-as-base');
cpsRatioCheckbox.addEventListener('change',async()=>onCompareCheckboxChange());
cpsToMapButton.addEventListener('click',()=>exportCpsMap(false,cpsCsvExportCheckbox.checked));
cpsRatioToMapButton.addEventListener('click',()=>exportRatioMap(false,cpsCsvExportCheckbox.checked));
cpsBinAvgToMapButton.addEventListener('click',()=>exportCpsMap(true,cpsCsvExportCheckbox.checked));
cpsRatioBinAvgToMapButton.addEventListener('click',()=>exportRatioMap(true,cpsCsvExportCheckbox.checked));
spgToSpectrumFileButton.addEventListener('click',()=>exportSpectrumRange());
spgAsBaseButton.addEventListener('click',()=>spectrumRangeAsBase());
previewCheckbox.addEventListener('change',async()=>awaitpreviewEnabledChange());
fromChannelInput1.addEventListener('change',async()=>awaitonChannelIndexInputChange());
toChannelInput1.addEventListener('change',async()=>awaitonChannelIndexInputChange());
fromChannelInput2.addEventListener('change',async()=>awaitonChannelIndexInputChange());
toChannelInput2.addEventListener('change',async()=>awaitonChannelIndexInputChange());
fromSpectrumInput.addEventListener('change',async()=>awaitonSpectrumIndexInputChange());
toSpectrumInput.addEventListener('change',async()=>awaitonSpectrumIndexInputChange());
//end

constplotContainer=document.getElementById('plot-container');
constwaterfallCanvas=document.getElementById('waterfall-plot');
constcpsCanvas=document.getElementById('cps-plot');
constpreviewContainer=document.getElementById('preview-container');
constpreviewCanvas=document.getElementById('preview-plot');

//hotkeys
constkeyboardState={
pressedKeyCode:undefined,
alt:false
};
document.body.addEventListener('keydown',(e)=>onKeyDown(e));
document.body.addEventListener('keyup',(e)=>onKeyUp(e));
waterfallCanvas.addEventListener('dblclick',(e)=>onWaterfallPaletteChange());
waterfallCanvas.addEventListener('click',(e)=>onWaterfallClick(e));
cpsCanvas.addEventListener('click',(e)=>onCpsClick(e));
//end

window.controlPanel={
setSubtractBase:(value)=>setSubtractBase(value),
markBaseChanged:()=>markBaseChanged(),
resetBaseChanged:()=>resetBaseChanged(),
resetWaterfallBinning:(channelBinning)=>resetWaterfallBinning(channelBinning),
resetMovingAverage:()=>resetMovingAverage(),
applyBinningAndAverage:()=>applyBinningAndAverage(),
applyBinningAndAverageAsync:()=>{
returncommon.executeWithStatusAsync('Processing...',()=>applyBinningAndAverage());
},
showPreview:()=>showPreview(),
hidePreview:()=>hidePreview(),
initCpsControls:()=>initCpsControls(),
};

lettmpRangeStart=-1;
functiononKeyDown(e){
if(e.code.startsWith('Key')){
constpreviousCode=keyboardState.pressedKeyCode;
keyboardState.pressedKeyCode=e.code;

switch(e.code){
case'KeyS':
case'KeyC':
case'KeyA':
if(previousCode!==e.code){
tmpRangeStart=-1;
}

break;
}
}
}

functiononKeyUp(e){
if(e.code.startsWith('Key')){
keyboardState.pressedKeyCode=undefined;
}
}

asyncfunctiononWaterfallClick(e){
if(keyboardState.pressedKeyCode==='KeyS'){
constspectrumIndex=cursorControl.getWFOriginalSpectrumIndex(e);
if(tmpRangeStart===-1){
fromSpectrumInput.value=spectrumIndex;
toSpectrumInput.value=spectrumIndex;
tmpRangeStart=spectrumIndex;
}else{
fromSpectrumInput.value=spectrumIndex<tmpRangeStart?spectrumIndex:tmpRangeStart;
toSpectrumInput.value=spectrumIndex>tmpRangeStart?spectrumIndex:tmpRangeStart;
tmpRangeStart=-1;
}

awaitonSpectrumIndexInputChange();
}

if(keyboardState.pressedKeyCode==='KeyC'){
constchannelIndex=cursorControl.getWFChannelIndex(e);
if(tmpRangeStart===-1){
fromChannelInput1.value=channelIndex;
toChannelInput1.value=channelIndex;
tmpRangeStart=channelIndex;
}else{
fromChannelInput1.value=channelIndex<tmpRangeStart?channelIndex:tmpRangeStart;
toChannelInput1.value=channelIndex>tmpRangeStart?channelIndex:tmpRangeStart;
tmpRangeStart=-1;
}

awaitonChannelIndexInputChange();
}

if(keyboardState.pressedKeyCode==='KeyA'){
constchannelIndex=cursorControl.getWFChannelIndex(e);
if(tmpRangeStart===-1){
fromChannelInput2.value=channelIndex;
toChannelInput2.value=channelIndex;
tmpRangeStart=channelIndex;
}else{
fromChannelInput2.value=channelIndex<tmpRangeStart?channelIndex:tmpRangeStart;
toChannelInput2.value=channelIndex>tmpRangeStart?channelIndex:tmpRangeStart;
tmpRangeStart=-1;
}

awaitonChannelIndexInputChange();
}
}

asyncfunctiononCpsClick(e){
if(keyboardState.pressedKeyCode==='KeyS'){
constspectrumIndex=cursorControl.getCpsOriginalSpectrumIndex(e);
if(tmpRangeStart===-1){
fromSpectrumInput.value=spectrumIndex;
toSpectrumInput.value=spectrumIndex;
tmpRangeStart=spectrumIndex;
}else{
fromSpectrumInput.value=spectrumIndex<tmpRangeStart?spectrumIndex:tmpRangeStart;
toSpectrumInput.value=spectrumIndex>tmpRangeStart?spectrumIndex:tmpRangeStart;
tmpRangeStart=-1;
}

awaitonSpectrumIndexInputChange();
}
}

asyncfunctiononWaterfallPaletteChange(value){
constpaletteList=['iron','lime','yellow','glow','gray'];
if(value){
waterfallState.palette=value;
}else{
constselected=paletteList.indexOf(waterfallState.palette);
if(selected===paletteList.length-1){
waterfallState.palette=paletteList[0];
}else{
waterfallState.palette=paletteList[selected+1];
}

palette.value=waterfallState.palette;
}

awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
}

functionshowPreview(){
waterfallState.previewEnabled=true;
plotContainer.classList.add('with-preview');
previewContainer.style.display='block';
previewCanvas.height=0;
}

functionhidePreview(){
waterfallState.previewEnabled=false;
plotContainer.classList.remove('with-preview');
previewContainer.style.display='none';
}

functionsetSubtractBase(value){
if(value&&waterfallData.baseSpectrum.duration<=0){
alert('Error:cannotsubtractbasespectrumbecauseitsdurationiszero.');
value=false;
}
subtractCheckbox.checked=value;
waterfallState.subtractBase=value;
}

functionmarkBaseChanged(){
if(subtractLabel.innerText.indexOf('*')===-1){
subtractLabel.innerText+='*';
subtractLabel.title='basehasbeensetfromspectrogram';
}
}

functionresetBaseChanged(){
if(subtractLabel.innerText.indexOf('*')!==-1){
subtractLabel.innerText=subtractLabel.innerText.replace('*','');
subtractLabel.title='';
}
}

functionresetWaterfallBinning(channelBinning){
waterfallState.spectrumBinning=1;
spectrumBinningInput.value=waterfallState.spectrumBinning;

waterfallState.channelBinning=channelBinning>=originalWaterfallData.channelBinning
?channelBinning
:originalWaterfallData.channelBinning;
channelBinningInput.value=waterfallState.channelBinning;
constopts=channelBinningInput.getElementsByTagName('option');
[...opts].forEach(opt=>{
opt.disabled=parseInt(opt.value)<originalWaterfallData.channelBinning;
});
}

functionresetMovingAverage(){
waterfallState.movingAverageVertical=0;
waterfallState.movingAverageHorizontal=0;
movingAverageVerticalInput.value=0;
movingAverageHorizontalInput.value=0;
}

asyncfunctiononWaterfallScaleChange(value){
waterfallState.scale=value;
awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
awaitcpsPlot.renderCpsAsync();
}

asyncfunctiononWaterfallBlurChange(value){
waterfallState.blur=value;
awaitwaterfallPlot.renderWaterfallImageAsync();
}

asyncfunctiononWaterfallSubtractChange(value){
setSubtractBase(value);
awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
awaitcpsPlot.renderCpsAsync();
}

asyncfunctiononSpectrumBinningChange(value){
letnewBin=parseInt(value);
if(isNaN(newBin)||newBin<1){
newBin=1;
spectrumBinningInput.value=newBin;
}

waterfallState.spectrumBinning=newBin;

awaitcontrolPanel.applyBinningAndAverageAsync();
awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
awaitcpsPlot.renderCpsAsync();
}

asyncfunctiononChannelBinningChange(value){
constnewBin=parseInt(value);
constprevBin=waterfallState.channelBinning;
waterfallState.channelBinning=newBin;

awaitcontrolPanel.applyBinningAndAverageAsync();
awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();

updateInputChannelValue(fromChannelInput1,newBin,prevBin);
updateInputChannelValue(toChannelInput1,newBin,prevBin);
updateInputChannelValue(fromChannelInput2,newBin,prevBin);
updateInputChannelValue(toChannelInput2,newBin,prevBin);

awaitonChannelIndexInputChange();
}

asyncfunctiononVerticalMovingAverageChange(value){
letwindowSize=parseInt(value);

if(isNaN(windowSize)||windowSize<0){
movingAverageVerticalInput.value=0;
windowSize=0;
}

if(windowSize===waterfallState.movingAverageVertical){
return;
}

waterfallState.movingAverageVertical=windowSize;
awaitcontrolPanel.applyBinningAndAverageAsync();
awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
awaitcpsPlot.renderCpsAsync();
}

asyncfunctiononHorizontalMovingAverageChange(value){
letwindowSize=parseInt(value);

if(isNaN(windowSize)||windowSize<0){
movingAverageHorizontalInput.value=0;
windowSize=0;
}

if(windowSize===waterfallState.movingAverageHorizontal){
return;
}

waterfallState.movingAverageHorizontal=windowSize;
awaitcontrolPanel.applyBinningAndAverageAsync();
awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
awaitcpsPlot.renderCpsAsync();
}

asyncfunctiononMaxCpsChange(value){
letnewVal=parseFloat(value);
if(isNaN(newVal)||newVal<1){
newVal=100;
maxCpsInput.value=newVal;
}

waterfallState.maxCpsPercent=newVal;
if(waterfallState.minCpsPercent>newVal){
waterfallState.minCpsPercent=newVal-1;
minCpsInput.value=waterfallState.minCpsPercent;
}

awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
}

asyncfunctiononMinCpsChange(value){
letnewVal=parseFloat(value);
if(isNaN(newVal)||newVal<0){
newVal=0;
minCpsInput.value=newVal;
}

waterfallState.minCpsPercent=newVal;
if(waterfallState.maxCpsPercent<newVal){
waterfallState.maxCpsPercent=newVal+1;
maxCpsInput.value=waterfallState.maxCpsPercent;
}

awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
}

asyncfunctiononTimezoneChange(value){
if(value==='local'){
waterfallState.timeOffsetHours=common.getLocalTimeOffsetHours();
}else{
waterfallState.timeOffsetHours=parseInt(value);
}

//TODO:call'renderaxis'wouldbebetterhere
awaitwaterfallPlot.renderSpectrumSelectionAsync();
}

functionupdateInputChannelValue(input,newBin,prevBin){
constprevVal=parseInt(input.value);

if(!isNaN(prevVal)){
letnewVal=Math.round((prevVal/newBin)*prevBin);
if(newVal<0){
newVal=0;
}
if(newVal>waterfallData.baseSpectrum.channelCount-1){
newVal=waterfallData.baseSpectrum.channelCount-1;
}
input.value=newVal;
}
}

functionapplyBinningAndAverage(){
waterfallData=exports.createWaterfallData(
originalWaterfallData.baseSpectrum,
originalWaterfallData.deltas,
waterfallState.channelBinning/originalWaterfallData.channelBinning,
waterfallState.spectrumBinning
);

applyMovingAverage();
}

functionapplyMovingAverage(){
//horizontalaverage
letwindowSize=waterfallState.movingAverageHorizontal;
letleftNeighbors=Math.floor(windowSize/2);
letrightNeighbors=Math.ceil(windowSize/2);
letavgDeltas=[];
for(leti=0;i<waterfallData.deltas.length;i++){
constavgDelta={
...waterfallData.deltas[i],
channels:newFloat32Array(waterfallData.baseSpectrum.channelCount)
};
for(letj=0;j<waterfallData.deltas[i].channels.length;j++){
avgDelta.channels[j]=waterfallData.deltas[i].channels[j];
letappliedSize=0;
for(letk=j-leftNeighbors;k<=j+rightNeighbors;k++){
if(k<0||k===j){
continue;
}
if(k>=waterfallData.deltas[i].channels.length){
break;
}
avgDelta.channels[j]+=waterfallData.deltas[i].channels[k];
appliedSize++;
}
avgDelta.channels[j]/=appliedSize+1;
}

avgDeltas.push(avgDelta);
}
waterfallData.deltas=avgDeltas;

//basespectrum
constchannels=newFloat32Array(waterfallData.baseSpectrum.channelCount);
for(letj=0;j<waterfallData.baseSpectrum.channels.length;j++){
channels[j]=waterfallData.baseSpectrum.channels[j];
letappliedSize=0;
for(letk=j-leftNeighbors;k<=j+rightNeighbors;k++){
if(k<0||k===j){
continue;
}
if(k>=waterfallData.baseSpectrum.channels.length){
break;
}
channels[j]+=waterfallData.baseSpectrum.channels[k];
appliedSize++;
}
channels[j]/=appliedSize+1;
}
waterfallData.baseSpectrum.channels=channels;

//verticalaverage
windowSize=waterfallState.movingAverageVertical;
leftNeighbors=Math.floor(windowSize/2);
rightNeighbors=Math.ceil(windowSize/2);
avgDeltas=[];
for(leti=0;i<waterfallData.deltas.length;i++){
constavgDelta={
...waterfallData.deltas[i],
channels:newFloat32Array(waterfallData.deltas[i].channels)
};
for(letj=0;j<avgDelta.channels.length;j++){
letappliedSize=0;
for(letk=i-leftNeighbors;k<=i+rightNeighbors;k++){
if(k<0||k===i){
continue;
}

if(k>=waterfallData.deltas.length){
break;
}

avgDelta.channels[j]+=waterfallData.deltas[k].channels[j]*(waterfallData.deltas[i].duration/waterfallData.deltas[k].duration);
appliedSize++;
}

avgDelta.channels[j]/=appliedSize+1;
}

avgDeltas.push(avgDelta);
}

waterfallData.deltas=avgDeltas;
}

functioninitCpsControls(){
waterfallState.channelRange1=[0,waterfallData.baseSpectrum.channelCount-1];
waterfallState.channelRange2=[0,waterfallData.baseSpectrum.channelCount-1];
waterfallState.spectrumRange=[0,waterfallData.deltas.length-1];

fromChannelInput1.value=waterfallState.channelRange1[0];
toChannelInput1.value=waterfallState.channelRange1[1];
fromChannelInput2.value=waterfallState.channelRange2[0];
toChannelInput2.value=waterfallState.channelRange2[1];
fromSpectrumInput.value=waterfallState.spectrumRange[0];
toSpectrumInput.value=waterfallState.spectrumRange[1];
}

asyncfunctiononCompareCheckboxChange(){
waterfallState.compareCps=cpsRatioCheckbox.checked;
cpsRatioToMapButton.disabled=!waterfallState.compareCps;
cpsRatioBinAvgToMapButton.disabled=!waterfallState.compareCps;

awaitwaterfallPlot.renderChannelSelectionAsync();
awaitcpsPlot.renderCpsAsync();
}

asyncfunctiononChannelIndexInputChange(){
waterfallState.channelRange1=getChannelRange(fromChannelInput1,toChannelInput1);
waterfallState.channelRange2=getChannelRange(fromChannelInput2,toChannelInput2);

awaitwaterfallPlot.renderChannelSelectionAsync();
awaitcpsPlot.renderCpsAsync();
}

functiongetChannelRange(fromInput,toInput){
letfromChannel=parseInt(fromInput.value);
lettoChannel=parseInt(toInput.value);

if(isNaN(fromChannel)||fromChannel<0){
fromChannel=0;
fromInput.value=0;
}

if(fromChannel>waterfallData.baseSpectrum.channelCount-1){
fromChannel=waterfallData.baseSpectrum.channelCount-1;
fromInput.value=waterfallData.baseSpectrum.channelCount-1;
}

if(isNaN(toChannel)||toChannel>waterfallData.baseSpectrum.channelCount-1){
toChannel=waterfallData.baseSpectrum.channelCount-1;
toInput.value=waterfallData.baseSpectrum.channelCount-1;
}

if(fromChannel>toChannel){
toChannel=fromChannel;
fromInput.value=fromChannel;
toInput.value=toChannel;
}

return[fromChannel,toChannel];
}

asyncfunctiononSpectrumIndexInputChange(){
waterfallState.spectrumRange=getSpectrumRange();
if(waterfallState.spectrumRange&&waterfallState.spectrumRange.length===2){
awaitwaterfallPlot.renderSpectrumSelectionAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
}
}

functiongetSpectrumRange(){
letfromSpectrum=parseInt(fromSpectrumInput.value);
lettoSpectrum=parseInt(toSpectrumInput.value);
if(isNaN(fromSpectrum)||fromSpectrum<0){
fromSpectrum=0;
fromSpectrumInput.value=0;
}

if(fromSpectrum>originalWaterfallData.deltas.length-1){
fromSpectrum=originalWaterfallData.deltas.length-1;
fromSpectrumInput.value=originalWaterfallData.deltas.length-1;
}

if(isNaN(toSpectrum)||toSpectrum>originalWaterfallData.deltas.length-1){
toSpectrum=originalWaterfallData.deltas.length-1;
toSpectrumInput.value=originalWaterfallData.deltas.length-1;
}

if(fromSpectrum>toSpectrum){
toSpectrum=fromSpectrum;
fromSpectrumInput.value=fromSpectrum;
toSpectrumInput.value=toSpectrum;
}

return[fromSpectrum,toSpectrum];
}

asyncfunctionpreviewEnabledChange(){
if(previewCheckbox.checked){
controlPanel.showPreview();
if(waterfallState.spectrumRange&&waterfallState.spectrumRange.length===2){
awaitwaterfallPlot.renderSpectrumImageAsync();
}
}else{
controlPanel.hidePreview();
}
}

functionexportCpsMap(binAvg,csv){
debugger;
constrange=waterfallState.channelRange1;
if(!range||range.length!==2){
alert('Error:invalidchannelrange1.');
return;
}

constenergyRange=getEnergyRangeStr(range);
constdescription=originalWaterfallData.baseSpectrum.name+'CP2S:cpsinrange'+energyRange;
letdata='';
if(csv){
if(binAvg){
data=exports.getCSV(
waterfallData.deltas,
range,
undefined,
waterfallState.timeOffsetHours
);
}else{
data=exports.getCSV(
originalWaterfallData.deltas,
common.rangeToOriginalRange(range),
undefined,
waterfallState.timeOffsetHours
);
}
}else{
if(binAvg){
data=exports.getRctrkData(
description,
waterfallData.deltas,
range,
undefined,
);
}else{
data=exports.getRctrkData(
description,
originalWaterfallData.deltas,
common.rangeToOriginalRange(range),
undefined
);
}
}

letfilename=originalWaterfallData.baseSpectrum.name+'-'+energyRange+'-cps';
if(csv){
saveFile(filename,'csv',data,'text/csv');
}else{
saveFile(filename,'rctrk',data,'text/rctrk');
return;
}
}

functionexportRatioMap(binAvg,csv){
debugger;
constrange=waterfallState.channelRange1;
if(!range||range.length!==2){
alert('Error:invalidchannelrange1.');
return;
}
constcompareRange=waterfallState.channelRange2;
if(!compareRange||compareRange.length!==2){
alert('Error:invalidchannelrange2.');
return;
}
constenergyRange=getEnergyRangeStr(range);
constcompareEnergyRange=getEnergyRangeStr(compareRange);
constdescription=originalWaterfallData.baseSpectrum.name+'CP2S:cpsratioforranges'+energyRange+'/'+compareEnergyRange;

letdata='';
if(csv){
if(binAvg){
data=exports.getCSV(
waterfallData.deltas,
range,
compareRange,
waterfallState.timeOffsetHours
);
}else{
data=exports.getCSV(
originalWaterfallData.deltas,
common.rangeToOriginalRange(range),
common.rangeToOriginalRange(compareRange),
waterfallState.timeOffsetHours
);
}
}else{
if(binAvg){
data=exports.getRctrkData(
description,
waterfallData.deltas,
range,
compareRange
);
}else{
data=exports.getRctrkData(
description,
originalWaterfallData.deltas,
common.rangeToOriginalRange(range),
common.rangeToOriginalRange(compareRange)
);
}
}

letfilename=originalWaterfallData.baseSpectrum.name+'-'+energyRange+compareEnergyRange+'-cps-ratio';
if(csv){
saveFile(filename,'csv',data,'text/csv');
}else{
saveFile(filename,'rctrk',data,'text/rctrk');
}
}

functionexportSpectrumRange(){
constrange=waterfallState.spectrumRange;
if(!range||range.length!==2){
alert('Error:invalidfromortospectrumindex.');
return;
}

if(originalWaterfallData.channelBinning!==1){
alert('Exportto'+originalWaterfallData.baseSpectrum.channelCount+'channelsduetochannelbinningappliedbyCLIorduringimport.');
}

constcombinedSpectrum=exports.combineDeltas(
originalWaterfallData.deltas,
range[0],
range[1],
originalWaterfallData.baseSpectrum,
originalWaterfallData.filename
);
constspectrumText=exports.serializeSpectrum(combinedSpectrum);
constfilename=originalWaterfallData.baseSpectrum.name+'-['+range[0]+','+range[1]+']';

saveFile(filename+'-combined','txt',spectrumText,'text/plain');
}

asyncfunctionspectrumRangeAsBase(){
constrange=waterfallState.spectrumRange;
if(!range||range.length!==2){
alert('Error:invalidfromortospectrumindex.');
return;
}

constcombinedSpectrum=exports.combineDeltas(
originalWaterfallData.deltas,
range[0],
range[1],
originalWaterfallData.baseSpectrum,
originalWaterfallData.filename
);
originalWaterfallData.baseSpectrum=combinedSpectrum;

controlPanel.setSubtractBase(true);
controlPanel.markBaseChanged();
awaitcontrolPanel.applyBinningAndAverageAsync();
awaitwaterfallPlot.renderWaterfallImageAsync();
awaitwaterfallPlot.renderSpectrumImageAsync();
awaitcpsPlot.renderCpsAsync();
}

functionsaveFile(filename,extension,data,mimeType){
letuserFilename=prompt("Pleaseenterfilename",filename);
if(userFilename==null){
return;
}

if(!userFilename){
userFilename=filename;
}

constblob=newBlob([data],{type:mimeType});
constelem=window.document.createElement('a');
elem.href=window.URL.createObjectURL(blob);
elem.download=userFilename+'.'+extension;
document.body.appendChild(elem);
elem.click();
document.body.removeChild(elem);
}

functiongetEnergyRangeStr(range){
letfromE=common.channelToEnergy(range[0]).toFixed(0);
if(fromE<0){
fromE=0;
}
lettoE=common.channelToEnergy(range[1]).toFixed(0);
if(toE<0){
toE=0;
}

return'['+fromE+'-'+toE+'keV]';
}
})();
