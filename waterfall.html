<html>
	<head>
		<style>
			body {
				background: #444;
				color: #CCC;
				min-width: 1100px;
				padding: 8px;
			}
			body * {
				font-size: 18px;
   				font-family: monospace;
			}
			select, input {
				background: #444;
				color: #CCC;
			}
			input[type="number"] {
				border: 1px solid #CCC;
			}
			.upload-controls {
				border-bottom: 1px dotted;
				margin-top: 16px;
				margin-bottom: 24px;
				padding-bottom: 4px;
				text-wrap: nowrap;
			}
			.upload-controls input {
				width: 600px;
			}
			.waterfall-control, .cps-control {
				width: 100%;
				border-bottom: 1px dotted;
				margin: 4px 0;
			}
			.row {
				display: inline-block;
				margin-bottom: 12px;
				text-wrap: nowrap;
				width: 100%;
			}
			.col {
				display: inline-block;
				text-wrap: nowrap;
				width: 280px;
			}
			.col label {
				margin-left: 4px;
			}
			.col select {
				margin-left: 16px;
			}
			.scale-switch {
				display: inline-block;
				margin-right: 16px;
			}
			.plot-container {
				position: relative;
				width: fit-content;
			}
			.plot {
				border: 1px dashed #222;
			}
			.horizontal-cursor, .vertical-cursor {
				display: none;
				position: absolute;
			}
			.horizontal-cursor {
				border-top: 1px dotted #777;
				height: 0;
				right: 0;
				width: calc(100% - 150px);
			}
			.vertical-cursor {
				border-left: 1px dotted #777;
				height: 100%;
				top: 0;
				width: 0;
			}
			.cps-control .numeric-input {
				margin: 0 4px;
				width: 120px;
			}
			.cps-left-column {
				display: inline-block;
				width: 400px;
			}
			.export-map-button {
				margin-left: 4px;
				width: 400px;
			}
			.error {
				color: orangered;
			}
			.blocking-overlay {
				position: absolute;
				background: rgba(100, 100, 100, 0.75);
				top: 64px;
				bottom: 0;
				left: 0;
				right: 0;
				min-width: 1132px;
			}
		</style>
		<script>
			window.onerror = function(msg, url, lineNo, columnNo, error) {
				const div = document.createElement('div');
				div.className = "row error";
				div.innerText = msg + ' (line: ' + lineNo + ', column: ' + columnNo + ')';
				document.body.appendChild(div);
			};
		</script>
		<script>
			window.originalWaterfallData = 'waterfall-data-placeholder';
			window.exports = {}; // hack to re-use nodejs modules
			window.require = () => window.exports;
		</script>
		<script src="./spectrum.js"></script>
		<script src="./waterfall-data.js"></script>
		<script src="./radiacode.js"></script> <!-- to be replaced with atom.js -->
	</head>
	<body>
		<div id="blocking-overlay" class="blocking-overlay"></div>
		<div id="upload-controls" class="upload-controls">
			<span>Select atomspectra file to render:</span>
			<input id="file-input" type="file" accept=".txt" name="files" onchange="onFileChange(this)">
		</div>
		<div class="waterfall-control">
			<div class="row">
				<div class="col">
					<input type="radio" id="lin" name="scale" value="lin" onchange="onWaterfallScaleChange(this.value)">
					<label for="lin">LIN</label>
					<input type="radio" id="sqrt" name="scale" value="sqrt" checked onchange="onWaterfallScaleChange(this.value)">
					<label for="sqrt">SQRT</label>
					<input type="radio" id="log" name="scale" value="log" onchange="onWaterfallScaleChange(this.value)">
					<label for="log">LOG</label>
				</div>
				<div class="col">
					<label for="spectrum-binning">Spectrum binning:</label>
					<select name="spectrum-binning" id="spectrum-binning" onchange="onSpectrumBinningChange(this.value)">
						<option value="1">1</option>
						<option value="2">2</option>
						<option value="3">3</option>
						<option value="4">4</option>
						<option value="5">5</option>
						<option value="6">6</option>
						<option value="7">7</option>
						<option value="8">8</option>
						<option value="9">9</option>
						<option value="10">10</option>
						<option value="25">25</option>
						<option value="50">50</option>
						<option value="100">100</option>
					</select>
				</div>
				<div class="col">
					<label for="channel-binning">Channel binning:</label>
					<select name="channel-binning" id="channel-binning" onchange="onChannelBinningChange(this.value)">
						<option value="1">1</option>
						<option value="2">2</option>
						<option value="4">4</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
				</div>
				<div class="col">
					<label for="moving-average">Moving average:</label>
					<select name="moving-average" id="moving-average" onchange="onMovingAverageChange(this.value)">
						<option value="0">0</option>
						<option value="2">2</option>
						<option value="4">4</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
				</div>
			</div>
			<div class="row">
				<div class="col">
					<input type="checkbox" id="blur-waterfall" name="blur-waterfall" onchange="onWaterfallBlurChange(this.checked)"/>
					<label for="blur-waterfall">Blur</label>
				</div>
				<div class="col">
					<input type="checkbox" id="subtract-base" name="subtract-base" onchange="onWaterfallSubtractChange(this.checked)"/>
					<label for="subtract-base">Subtract base spectrum</label>
				</div>
			</div>
		</div>
		<div class="plot-container">
			<canvas id="waterfall-plot" class="plot" width="0" height="0"></canvas>
			<div id="horizontal-cursor" class="horizontal-cursor"></div>
			<div id="vertical-cursor" class="vertical-cursor"></div>
		</div>
		<div class="cps-control">
			<div class="row">
				<button class="cps-left-column" onclick="renderCps()">CPS trend in channel range:</button> 
				<input type="number" id="from-channel-1" class="numeric-input"/>-<input type="number" id="to-channel-1" class="numeric-input"/>
				<button id="export-cps-map" class="export-map-button" disabled onclick="exportCpsMap(this)">Range 1 cps to map</button>
			</div>
			<div class="row">
				<div class="cps-left-column">
					<input type="checkbox" id="cps-comparison" name="cps-comparison"/>
					<label for="cps-comparison">Compare to CPS in channel range:</label>
				</div>
				<input type="number" id="from-channel-2" class="numeric-input"/>-<input type="number" id="to-channel-2" class="numeric-input"/>
				<button id="export-comparison-map" class="export-map-button" disabled onclick="exportComparisonMap(this)">Range 1/range 2 comparison to map</button>
			</div>
			<div class="row">
				<input type="checkbox" id="dotted-trend" name="dotted-trend"/>
				<label for="dotted-trend">Dotted</label>
			</div>
		</div>
		<div class="plot-container">
			<canvas id="cps-plot" class="plot" width="0" height="0"></canvas>
			<div id="cps-vertical-cursor" class="vertical-cursor"></div>
		</div>
		<script>
			// display configuration/state
			window.constants = {
				timestampWidth: 150, // note: the same in css
				timestampHeight: 20,
				timestampTickWidth: 10,
				channelAxisHeight: 32,
				channelAxisTickHeight: 4,
				backgroundColor: 'black',
				textColor: 'lightgray',
				lineColor: 'lightgray',
				separatorLineColor: '#777',
				dotColor: 'white',
				cpsPlotHeight: 200,
				cpsExtendRange: 0.1,
				blurRadius: 1
			};
			window.waterfallState = {
				scale: 'sqrt',
				spectrumBinning: 1,
				channelBinning: 1,
				blur: false,
				subtractBase: false,
				movingAverage: 0,
			}
		</script>
		<script>
			// waterfall plot render
			function hexToRGB(hex) {
				var r = parseInt(hex.slice(1, 3), 16),
					g = parseInt(hex.slice(3, 5), 16),
					b = parseInt(hex.slice(5, 7), 16);
				
					return [r, g, b];
			}		

			function renderWaterfallImage() {
				const canvas = document.getElementById('waterfall-plot');
				canvas.width = waterfallData.baseSpectrum.channelCount + constants.timestampWidth;
				canvas.height = waterfallData.deltas.length + constants.channelAxisHeight;

				const ironPaletteHex = [
					"#00000a","#000014","#00001e","#000025","#00002a","#00002e","#000032","#000036",
					"#00003a","#00003e","#000042","#000046","#00004a","#00004f","#000052","#010055",
					"#010057","#020059","#02005c","#03005e","#040061","#040063","#050065","#060067",
					"#070069","#08006b","#09006e","#0a0070","#0b0073","#0c0074","#0d0075","#0d0076",
					"#0e0077","#100078","#120079","#13007b","#15007c","#17007d","#19007e","#1b0080",
					"#1c0081","#1e0083","#200084","#220085","#240086","#260087","#280089","#2a0089",
					"#2c008a","#2e008b","#30008c","#32008d","#34008e","#36008e","#38008f","#390090",
					"#3b0091","#3c0092","#3e0093","#3f0093","#410094","#420095","#440095","#450096",
					"#470096","#490096","#4a0096","#4c0097","#4e0097","#4f0097","#510097","#520098",
					"#540098","#560098","#580099","#5a0099","#5c0099","#5d009a","#5f009a","#61009b",
					"#63009b","#64009b","#66009b","#68009b","#6a009b","#6c009c","#6d009c","#6f009c",
					"#70009c","#71009d","#73009d","#75009d","#77009d","#78009d","#7a009d","#7c009d",
					"#7e009d","#7f009d","#81009d","#83009d","#84009d","#86009d","#87009d","#89009d",
					"#8a009d","#8b009d","#8d009d","#8f009c","#91009c","#93009c","#95009c","#96009b",
					"#98009b","#99009b","#9b009b","#9c009b","#9d009b","#9f009b","#a0009b","#a2009b",
					"#a3009b","#a4009b","#a6009a","#a7009a","#a8009a","#a90099","#aa0099","#ab0099",
					"#ad0099","#ae0198","#af0198","#b00198","#b00198","#b10197","#b20197","#b30196",
					"#b40296","#b50295","#b60295","#b70395","#b80395","#b90495","#ba0495","#ba0494",
					"#bb0593","#bc0593","#bd0593","#be0692","#bf0692","#bf0692","#c00791","#c00791",
					"#c10890","#c10990","#c20a8f","#c30a8e","#c30b8e","#c40c8d","#c50c8c","#c60d8b",
					"#c60e8a","#c70f89","#c81088","#c91187","#ca1286","#ca1385","#cb1385","#cb1484",
					"#cc1582","#cd1681","#ce1780","#ce187e","#cf187c","#cf197b","#d01a79","#d11b78",
					"#d11c76","#d21c75","#d21d74","#d31e72","#d32071","#d4216f","#d4226e","#d5236b",
					"#d52469","#d62567","#d72665","#d82764","#d82862","#d92a60","#da2b5e","#da2c5c",
					"#db2e5a","#db2f57","#dc2f54","#dd3051","#dd314e","#de324a","#de3347","#df3444",
					"#df3541","#df363d","#e0373a","#e03837","#e03933","#e13a30","#e23b2d","#e23c2a",
					"#e33d26","#e33e23","#e43f20","#e4411d","#e4421c","#e5431b","#e54419","#e54518",
					"#e64616","#e74715","#e74814","#e74913","#e84a12","#e84c10","#e84c0f","#e94d0e",
					"#e94d0d","#ea4e0c","#ea4f0c","#eb500b","#eb510a","#eb520a","#eb5309","#ec5409",
					"#ec5608","#ec5708","#ec5808","#ed5907","#ed5a07","#ed5b06","#ee5c06","#ee5c05",
					"#ee5d05","#ee5e05","#ef5f04","#ef6004","#ef6104","#ef6204","#f06303","#f06403",
					"#f06503","#f16603","#f16603","#f16703","#f16803","#f16902","#f16a02","#f16b02",
					"#f16b02","#f26c01","#f26d01","#f26e01","#f36f01","#f37001","#f37101","#f37201",
					"#f47300","#f47400","#f47500","#f47600","#f47700","#f47800","#f47a00","#f57b00",
					"#f57c00","#f57e00","#f57f00","#f68000","#f68100","#f68200","#f78300","#f78400",
					"#f78500","#f78600","#f88700","#f88800","#f88800","#f88900","#f88a00","#f88b00",
					"#f88c00","#f98d00","#f98d00","#f98e00","#f98f00","#f99000","#f99100","#f99200",
					"#f99300","#fa9400","#fa9500","#fa9600","#fb9800","#fb9900","#fb9a00","#fb9c00",
					"#fc9d00","#fc9f00","#fca000","#fca100","#fda200","#fda300","#fda400","#fda600",
					"#fda700","#fda800","#fdaa00","#fdab00","#fdac00","#fdad00","#fdae00","#feaf00",
					"#feb000","#feb100","#feb200","#feb300","#feb400","#feb500","#feb600","#feb800",
					"#feb900","#feb900","#feba00","#febb00","#febc00","#febd00","#febe00","#fec000",
					"#fec100","#fec200","#fec300","#fec400","#fec500","#fec600","#fec700","#fec800",
					"#fec901","#feca01","#feca01","#fecb01","#fecc02","#fecd02","#fece03","#fecf04",
					"#fecf04","#fed005","#fed106","#fed308","#fed409","#fed50a","#fed60a","#fed70b",
					"#fed80c","#fed90d","#ffda0e","#ffda0e","#ffdb10","#ffdc12","#ffdc14","#ffdd16",
					"#ffde19","#ffde1b","#ffdf1e","#ffe020","#ffe122","#ffe224","#ffe226","#ffe328",
					"#ffe42b","#ffe42e","#ffe531","#ffe635","#ffe638","#ffe73c","#ffe83f","#ffe943",
					"#ffea46","#ffeb49","#ffeb4d","#ffec50","#ffed54","#ffee57","#ffee5b","#ffee5f",
					"#ffef63","#ffef67","#fff06a","#fff06e","#fff172","#fff177","#fff17b","#fff280",
					"#fff285","#fff28a","#fff38e","#fff492","#fff496","#fff49a","#fff59e","#fff5a2",
					"#fff5a6","#fff6aa","#fff6af","#fff7b3","#fff7b6","#fff8ba","#fff8bd","#fff8c1",
					"#fff8c4","#fff9c7","#fff9ca","#fff9cd","#fffad1","#fffad4","#fffbd8","#fffcdb",
					"#fffcdf","#fffde2","#fffde5","#fffde8","#fffeeb","#fffeee","#fffef1","#fffef4",
					"#fffff6"
				];
				const ironPaletteRGB = ironPaletteHex.map(c => hexToRGB(c));

				const ctx = canvas.getContext("2d", { willReadFrequently: true });
				ctx.fillStyle = constants.backgroundColor;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				let maxCps = 0;
				waterfallData.deltas.forEach((delta, deltaIndex) => {
					delta.channels.forEach((channelValue, channelIndex) => {
						if (!channelValue) {
							return;
						}

						let cps = channelValue / delta.duration;
						// TODO: duplicated code
						if (waterfallState.subtractBase) {
							const baseCps = waterfallData.baseSpectrum.channels[channelIndex] / waterfallData.baseSpectrum.duration;
							cps -= baseCps;
							if (cps < 0) {
								cps = 0;
							}
						}

						maxCps = Math.max(maxCps, cps);
					});
				});

				// waterfall render
				const imageData = ctx.getImageData(constants.timestampWidth, 0, waterfallData.baseSpectrum.channelCount, waterfallData.deltas.length);
				waterfallData.deltas.forEach((delta, deltaIndex) => {
					delta.channels.forEach((channelValue, channelIndex) => {
						if (!channelValue) {
							return;
						}

						let cps = channelValue / delta.duration;
						// TODO: duplicated code
						if (waterfallState.subtractBase) {
							const baseCps = waterfallData.baseSpectrum.channels[channelIndex] / waterfallData.baseSpectrum.duration;
							cps -= baseCps;
							if (cps < 0) {
								cps = 0;
							}
						}

						const linearColorIndex = Math.round((cps / maxCps) * (ironPaletteRGB.length - 1));
						let colorIndex;

						switch (waterfallState.scale) {
							case 'log':
								colorIndex = Math.round((Math.log(linearColorIndex + 2) / Math.log(ironPaletteRGB.length)) * (ironPaletteRGB.length - 1));
								break;
							case 'sqrt':
								colorIndex = Math.round((Math.sqrt(linearColorIndex + 2) / Math.sqrt(ironPaletteRGB.length)) * (ironPaletteRGB.length - 1));
								break;
							default:
								colorIndex = linearColorIndex;
						}

						const rgbColor = ironPaletteRGB[colorIndex];
						const pxOffset = (deltaIndex * waterfallData.baseSpectrum.channelCount + channelIndex) * 4;
						imageData.data[pxOffset + 0] = rgbColor[0];
						imageData.data[pxOffset + 1] = rgbColor[1];
						imageData.data[pxOffset + 2] = rgbColor[2];
						imageData.data[pxOffset + 3] = 255;
					});
				});
				ctx.putImageData(imageData, constants.timestampWidth, 0);

				if (waterfallState.blur) {
					debugger;
					const blurData = ctx.createImageData(imageData.width, imageData.height);
					const radius = constants.blurRadius;
					for (let x = 0; x < imageData.width; x++) {
						for (let y = 0; y <= imageData.height; y++) {
							let r = 0;
							let g = 0;
							let b = 0;
							for (let ky = -radius; ky <= radius; ++ky) {
								for (let kx = -radius; kx <= radius; ++kx) {
									const sourcePxOffset = ((y + ky) * imageData.width + (x + kx)) * 4;
									if (sourcePxOffset < 0 || sourcePxOffset > imageData.data.length - 1) {
										continue;
									}

									r += imageData.data[sourcePxOffset + 0];
									g += imageData.data[sourcePxOffset + 1];
									b += imageData.data[sourcePxOffset + 2];
								}
							}
							
							const destPxOffset = (y * blurData.width + x) * 4;
							const coeff = Math.pow(radius + 1, 2) * 2.1;
							blurData.data[destPxOffset + 0] = r / coeff;
							blurData.data[destPxOffset + 1] = g / coeff;
							blurData.data[destPxOffset + 2] = b / coeff;
							blurData.data[destPxOffset + 3] = 255;
						}
					}

					ctx.putImageData(blurData, constants.timestampWidth, 0);
				}

				// time axis
				const timestamps = waterfallData.deltas.map(d => d.timestamp);
				for (let tsIndex = 0; tsIndex < timestamps.length; tsIndex += constants.timestampHeight) {
					const timestamp = timestamps[tsIndex];
					ctx.textBaseline = 'top';
					ctx.fillStyle = constants.textColor;
					const utcISO = new Date(timestamp).toISOString();
					let label = utcISO.split('T').join(' ').split('.')[0] + ' UTC';
					if (tsIndex % 100 === 0) {
						label += ': ' + tsIndex;
					}
					ctx.fillText(label, 0, tsIndex);

					// label tick
					const tickWidth = tsIndex % 100 === 0
						? constants.timestampTickWidth
						: constants.timestampTickWidth / 2;
					for (let x = constants.timestampWidth - tickWidth; x < constants.timestampWidth; x++) {
						ctx.fillRect(x, tsIndex, 1, 1);
					}
				}

				// calculate energy for each channel
				const allEnergies = [];
				for (let i = 0; i < waterfallData.baseSpectrum.channelCount; i++) {
					let energy = 0;
					for (let order = 0; order < waterfallData.baseSpectrum.calibration.length; order++) {
						energy += Math.pow(i, order) * waterfallData.baseSpectrum.calibration[order];
					}
					allEnergies.push(energy);
				}

				// calculate channels for 0, 100, 200, 300... enegries 
				const renderEnergies = {};
				for (let energy = 0, channel = 0; energy < allEnergies[allEnergies.length - 1]; energy += 100) {
					while (allEnergies[channel] < energy) {
						channel++;
					}
					renderEnergies[channel] = energy;
				}

				// energy axis render
				const energyAxisBaseline = waterfallData.deltas.length;
				const channelAxisBaseline = waterfallData.deltas.length + constants.channelAxisHeight / 2;
				let kevRendered = false;
				for (let x = constants.timestampWidth; x < canvas.width; x++) {
					const channelNumber = x - constants.timestampWidth;
					const energy = renderEnergies[channelNumber];

					if (energy != undefined && energy % 500 === 0) {
						ctx.textBaseline = 'top';
						ctx.fillStyle = constants.textColor;
						const label = kevRendered ? energy.toString() : energy + ' keV';
						ctx.fillText(label, x, energyAxisBaseline + constants.channelAxisTickHeight);
						kevRendered = true;
					}

					if (energy != undefined && energy % 100 === 0) {
						const tickHeight = energy % 500 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
						for (let y = energyAxisBaseline; y < energyAxisBaseline + tickHeight; y++) {
							ctx.fillRect(x, y, 1, 1);
						}
					}

					if (channelNumber % 100 === 0) {
						ctx.textBaseline = 'top';
						ctx.fillStyle = constants.textColor;
						const label = channelNumber === 0 ? channelNumber + ' channel' : channelNumber.toString();
						ctx.fillText(label, x, channelAxisBaseline + constants.channelAxisTickHeight);
					}

					if (channelNumber % 10 === 0) {
						const tickHeight = channelNumber % 50 === 0 ? constants.channelAxisTickHeight : constants.channelAxisTickHeight / 2;
						for (let y = channelAxisBaseline; y < channelAxisBaseline + tickHeight; y++) {
							ctx.fillRect(x, y, 1, 1);
						}
					}
				}
			}
		</script>
		<script>
			// cps plot render
			const fromChannelInput1 = document.getElementById('from-channel-1');
			const toChannelInput1 = document.getElementById('to-channel-1');
			const dottedCheckbox = document.getElementById('dotted-trend');
			const fromChannelInput2 = document.getElementById('from-channel-2');
			const toChannelInput2 = document.getElementById('to-channel-2');
			const compareCheckbox = document.getElementById('cps-comparison');
			const cpsToMapButton = document.getElementById('export-cps-map');
			const comparisonToMapButton = document.getElementById('export-comparison-map');
			
			function initCpsControls() {
				fromChannelInput1.value = 0;
				toChannelInput1.value = waterfallData.baseSpectrum.channelCount - 1;
				fromChannelInput2.value = 0;
				toChannelInput2.value = waterfallData.baseSpectrum.channelCount - 1;
			}

			function getCountsInRange(from, to) {
				from = from < 0 ? 0 : from;
				to = to >= waterfallData.baseSpectrum.channelCount 
					? waterfallData.baseSpectrum.channelCount - 1
					: to; 

				const countsInRange = {};
				waterfallData.deltas.forEach((delta, deltaIndex) => {
					for (let ci = from; ci <= to; ci++) {
						if (countsInRange[deltaIndex] === undefined) {
							countsInRange[deltaIndex] = delta.channels[ci];
						} else {
							countsInRange[deltaIndex] += delta.channels[ci];
						}

						if (waterfallState.subtractBase) {
							countsInRange[deltaIndex] -= waterfallData.baseSpectrum.channels[ci] * (delta.duration / waterfallData.baseSpectrum.duration);
						}
					}

					if (countsInRange[deltaIndex] < 0) {
						countsInRange[deltaIndex] = 0;
					}
				});
				
				return countsInRange;
			}
			
			function countsToCps(countsInRange) {
				const cpsInRange = {};
				Object.keys(countsInRange).forEach(deltaIndex => {
					cpsInRange[deltaIndex] = countsInRange[deltaIndex] / waterfallData.deltas[deltaIndex].duration;
				});
				
				return cpsInRange;
			}
			
			function getRenderData(valuesInRange) {
				let max = 0;
				let min = Infinity;
				for (let i = 0; i < waterfallData.deltas.length; i++) {
					if (valuesInRange[i] === undefined) {
						continue;
					}

					max = Math.max(max, valuesInRange[i]);
					min = Math.min(min, valuesInRange[i]);
				}

				if (max === 0 && min === 0) {
					max = 1;
					min = -1;
				}
				const range = max - min;
				max += constants.cpsExtendRange * (range === 0 ? max : range);
				min -= constants.cpsExtendRange * (range === 0 ? max : range);
			
				return {
					values: valuesInRange,
					max: max,
					min: min
				}
			}

			function renderCps() {
				const cpsCanvas = document.getElementById('cps-plot');
				cpsCanvas.width = waterfallData.deltas.length;
				cpsCanvas.height = constants.cpsPlotHeight;
			
				const fromChannel1 = parseInt(fromChannelInput1.value);
				const toChannel1 = parseInt(toChannelInput1.value);
				if (isNaN(fromChannel1) || isNaN(toChannel1) || fromChannel1 > toChannel1) {
					cpsToMapButton.disabled = true;
					comparisonToMapButton.disabled = true;
					renderCpsData(cpsCanvas);
					return;
				}
				
				const fromChannel2 = parseInt(fromChannelInput2.value);
				const toChannel2 = parseInt(toChannelInput2.value);
				if (compareCheckbox.checked && (isNaN(fromChannel2) || isNaN(toChannel2) || fromChannel2 > toChannel2)) {
					cpsToMapButton.disabled = true;
					comparisonToMapButton.disabled = true;
					renderCpsData(cpsCanvas);
					return;
				}

				if (compareCheckbox.checked) {
					comparisonToMapButton.disabled = false;
					cpsToMapButton.disabled = false;
					const countsInRange1 = getCountsInRange(fromChannel1, toChannel1);
					const cpsInRange1 = countsToCps(countsInRange1);
					const countsInRange2 = getCountsInRange(fromChannel2, toChannel2);
					const cpsInRange2 = countsToCps(countsInRange2);
					const ratio = {};
					for (let i = 0; i < waterfallData.deltas.length; i++) {
						if (cpsInRange1[i] !== undefined && cpsInRange2[i] > 0) {
							ratio[i] = cpsInRange1[i] / cpsInRange2[i];
						}
					}

					const plotHeight = constants.cpsPlotHeight;
					cpsCanvas.height = plotHeight * 3;
					renderCpsData(cpsCanvas, getRenderData(cpsInRange1), 0, plotHeight, 'range 1 cps');
					renderCpsData(cpsCanvas, getRenderData(cpsInRange2), plotHeight, plotHeight, 'range 2 cps');
					renderCpsData(cpsCanvas, getRenderData(ratio), plotHeight * 2, plotHeight, 'range 1 / range 2');
				} else {
					cpsToMapButton.disabled = false;
					comparisonToMapButton.disabled = true;
					const countsInRange1 = getCountsInRange(fromChannel1, toChannel1);
					const cpsInRange1 = countsToCps(countsInRange1);
					const renderData = getRenderData(cpsInRange1);

					renderCpsData(cpsCanvas, renderData, 0, cpsCanvas.height, 'range 1 cps');
				}
			}

			function renderCpsData(canvas, data, offset, height, label) {			
				const ctx = canvas.getContext("2d");
				ctx.fillStyle = constants.backgroundColor;
				ctx.fillRect(0, offset, canvas.width, height);

				if (!data) {
					return;
				}

				const range = data.max - data.min;
				if (dottedCheckbox.checked) {
					// points
					ctx.fillStyle = constants.dotColor;
					for (let x = 0; x < waterfallData.deltas.length; x++) {
						if (data.values[x] === undefined) {
							continue;
						}

						const y = height - ((data.values[x] - data.min) / range) * height + offset;
						ctx.fillRect(x, y, 1, 1);
					}
				} else {
					// lines
					ctx.beginPath();
					ctx.lineWidth = 1;
					ctx.setLineDash([1, 0]);
					ctx.strokeStyle = constants.lineColor;
					let firstMove = true;
					for (let x = 0; x < waterfallData.deltas.length; x++) {
						if (data.values[x] === undefined) {
							continue;
						}

						const y = height - ((data.values[x] - data.min) / range) * height + offset;

						if (firstMove) {
							ctx.moveTo(x, y);
							firstMove = false;
						} else {
							ctx.lineTo(x, y);
							ctx.moveTo(x, y);
						}
					}
					ctx.stroke();
				}

				// separator line
				if (offset > 0) {
					ctx.beginPath();
					ctx.lineWidth = 1;
					ctx.setLineDash([2, 2]);
					ctx.strokeStyle = constants.separatorLineColor;
					ctx.moveTo(0, offset - 0.5);
					ctx.lineTo(canvas.width, offset - 0.5);
					ctx.stroke();
				}

				// labels
				ctx.fillStyle = constants.textColor;
				ctx.textBaseline = 'top';
				ctx.fillText(data.max.toFixed(range < 0.01 ? 4 : 2), 0, offset);
				ctx.textBaseline = 'bottom';
				ctx.fillText(data.min.toFixed(range < 0.01 ? 4 : 2), 0, offset + height);
				ctx.textBaseline = 'top';
				ctx.fillText(label, canvas.width / 2 - label.length * 2, offset);
			}

			function exportCpsMap() {
				const range = [fromChannelInput1.value, toChannelInput1.value];
				const data = exports.getRctrkData(originalWaterfallData.baseSpectrum.name + ' CP2S: cps in range [' + range[0] + ', ' + range[1] + ']', 
					originalWaterfallData.deltas, range, undefined, waterfallState.channelBinning);

				saveRctrk(originalWaterfallData.baseSpectrum.name + '-cps.rctrk', data);
			}

			function exportComparisonMap() {
				const range = [fromChannelInput1.value, toChannelInput1.value];
				const compareRange = [fromChannelInput2.value, toChannelInput2.value];
				const data = exports.getRctrkData(originalWaterfallData.baseSpectrum.name + 
					' CP2S: cps comparison for ranges [' + range[0] + ', ' + range[1] + ']/[' + compareRange[0] + ', ' + compareRange[1] + ']', 
					originalWaterfallData.deltas, range, compareRange, waterfallState.channelBinning);

				saveRctrk(originalWaterfallData.baseSpectrum.name + '-cps-comparison.rctrk', data);
			}

			function saveRctrk(filename, data) {
				const blob = new Blob([data], { type: 'text/rctrk' }); // invalid mime type to force android save it as .rcspg
				const elem = window.document.createElement('a');
				elem.href = window.URL.createObjectURL(blob);
				elem.download = filename;
				document.body.appendChild(elem);
				elem.click();
				document.body.removeChild(elem);
			}
		</script>
		<script>
			// mouse cursor render
			const waterfallPlot = document.getElementById('waterfall-plot');
			const cpsPlot = document.getElementById('cps-plot');
			const horizontal = document.getElementById('horizontal-cursor');
			const vertical = document.getElementById('vertical-cursor');
			const cpsVertical = document.getElementById('cps-vertical-cursor')
			waterfallPlot.parentElement.addEventListener('mouseenter', e => waterfallOnEnter(e));
			waterfallPlot.parentElement.addEventListener('mouseleave', e => plotOnLeave(e));
			waterfallPlot.parentElement.addEventListener('mousemove', e => waterfallOnMove(e));
			cpsPlot.parentElement.addEventListener('mouseenter', e => cpsOnEnter(e));
			cpsPlot.parentElement.addEventListener('mouseleave', e => plotOnLeave(e));
			cpsPlot.parentElement.addEventListener('mousemove', e => cpsOnMove(e));
			horizontal.addEventListener('mousemove', e => onHorizontalWfMove(e, true));
			vertical.addEventListener('mousemove', e => onVerticalWfMove(e));

			function waterfallOnEnter() {
				horizontal.style.display = 'block';
				vertical.style.display = 'block';
				cpsVertical.style.display = 'block';
			}

			function cpsOnEnter() {
				horizontal.style.display = 'block';
				vertical.style.display = 'none';
				cpsVertical.style.display = 'block';
			}

			function plotOnLeave(e) {
				if (isCursor(e.target)) {
					return;
				}

				horizontal.style.display = 'none';
				vertical.style.display = 'none';
				cpsVertical.style.display = 'none';
			}

			function waterfallOnMove(e) {
				if (isCursor(e.target)) {
					return;
				}

				onHorizontalWfMove(e, false);
				onVerticalWfMove(e);
			}

			function cpsOnMove(e) {
				if (isCursor(e.target)) {
					return;
				}

				// spectrum index
				let offsetX = e.offsetX;
				if (offsetX > 0) {
					offsetX--;
				}

				horizontal.style.top = offsetX;
				cpsVertical.style.left = offsetX;
			}

			function onHorizontalWfMove(e, cursorDivOffset) {
				// channel index
				let offsetX = cursorDivOffset
					? e.offsetX + constants.timestampWidth
					: e.offsetX;
				offsetX--;

				if (offsetX < constants.timestampWidth) {
					vertical.style.left = constants.timestampWidth;
				} else {
					vertical.style.left = offsetX;
				}
			}

			function onVerticalWfMove(e) {
				// spectrum index
				let offsetY = e.offsetY;
				if (offsetY > 0) {
					offsetY--;
				}

				if (e.offsetY > waterfallData.deltas.length) {
					horizontal.style.top = waterfallData.deltas.length;
					cpsVertical.style.left = waterfallData.deltas.length;
				} else {
					horizontal.style.top = offsetY;
					cpsVertical.style.left = offsetY;
				}
			}

			function isCursor(target) {
				return target === horizontal || target === vertical || target === cpsVertical;
			}
		</script>
		<script>
			// waterfall control
			function resetWaterfallBinning() {
				document.getElementById('spectrum-binning').value = 1;
				document.getElementById('channel-binning').value = 1;
				waterfallState.channelBinning = 1;
				waterfallState.spectrumBinning = 1;
			}

			function resetMovingAverage() {
				waterfallState.movingAverage = 0;
				document.getElementById('moving-average').value = 0;
			}

			function onWaterfallScaleChange(value) {
				waterfallState.scale = value;
				renderWaterfallImage();
			}

			function onWaterfallBlurChange(value) {
				waterfallState.blur = value;
				renderWaterfallImage();
			}

			function onWaterfallSubtractChange(value) {
				waterfallState.subtractBase = value;
				renderWaterfallImage();
				renderCps();
			}

			function onSpectrumBinningChange(value) {
				const newBin = parseInt(value);
				waterfallState.spectrumBinning = newBin;

				applyBinningAndAverage();
				renderWaterfallImage();
				renderCps();
			}

			function onChannelBinningChange(value) {
				const newBin = parseInt(value);
				const prevBin = waterfallState.channelBinning;
				waterfallState.channelBinning = newBin;

				applyBinningAndAverage();
				renderWaterfallImage();

				// TODO: refactor duplicated code
				const fromChannelInput1 = document.getElementById('from-channel-1');
				const toChannelInput1 = document.getElementById('to-channel-1');
				const fromChannelInput2 = document.getElementById('from-channel-2');
				const toChannelInput2 = document.getElementById('to-channel-2');

				updateInputChannelValue(fromChannelInput1, newBin, prevBin);
				updateInputChannelValue(toChannelInput1, newBin, prevBin);
				updateInputChannelValue(fromChannelInput2, newBin, prevBin);
				updateInputChannelValue(toChannelInput2, newBin, prevBin);

				renderCps();
			}

			function onMovingAverageChange(value) {
				const windowSize = parseInt(value);
				if (windowSize === waterfallState.movingAverage) {
					return;
				}
				waterfallState.movingAverage = windowSize;

				applyBinningAndAverage();
				renderWaterfallImage();
				renderCps();
			}
			
			function updateInputChannelValue(input, newBin, prevBin) {				
				const prevVal = parseInt(input.value);

				if (!isNaN(prevVal)) {
					let newVal = Math.round((prevVal / newBin) * prevBin);
					if (newVal < 0) {
						newVal = 0;
					}
					if (newVal > waterfallData.baseSpectrum.channelCount - 1) {
						newVal = waterfallData.baseSpectrum.channelCount - 1;
					}
					input.value = newVal;
				}
			}

			function applyBinningAndAverage() {
				const deltas = exports.reduceSpectrumCount(originalWaterfallData.deltas, waterfallState.spectrumBinning);
				waterfallData = exports.createWaterfallData(originalWaterfallData.baseSpectrum, deltas, waterfallState.channelBinning);
				applyMovingAverage();
			}

			function applyMovingAverage() {
				windowSize = waterfallState.movingAverage;
				// horizontal average
				let avgDeltas = [];
				for (let i = 0; i < waterfallData.deltas.length; i++) {
					const avgDelta = {
						...waterfallData.deltas[i],
						channels: []
					};
					for (let j = 0; j < waterfallData.deltas[i].channels.length; j++) {
						avgDelta.channels.push(waterfallData.deltas[i].channels[j]);
						let appliedSize = 0;
						for (let k = j - windowSize / 2; k <= j + windowSize / 2; k++) {
							if (k < 0 || k === j) {
								continue;
							}
							if (k >= waterfallData.deltas[i].channels.length) {
								break;
							}
							avgDelta.channels[j] += waterfallData.deltas[i].channels[k];
							appliedSize++;
						}
						avgDelta.channels[j] /= appliedSize + 1;
					}

					avgDeltas.push(avgDelta);
				}
				waterfallData.deltas = avgDeltas;

				// vertical average
				avgDeltas = [];
				for (let i = 0; i < waterfallData.deltas.length; i++) {
					const avgDelta = {
						...waterfallData.deltas[i],
						channels: [...waterfallData.deltas[i].channels]
					};
					for (let j = 0; j < avgDelta.channels.length; j++) {
						let appliedSize = 0;
						for (let k = i - windowSize / 2; k <= i + windowSize / 2; k++) {
							if (k < 0 || k === i) {
								continue;
							}

							if (k >= waterfallData.deltas.length) {
								break;
							}

							avgDelta.channels[j] += waterfallData.deltas[k].channels[j] * (waterfallData.deltas[i].duration / waterfallData.deltas[k].duration);
							appliedSize++;
						}

						avgDelta.channels[j] /= appliedSize + 1;
					}

					avgDeltas.push(avgDelta);
				}

				waterfallData.deltas = avgDeltas;
			}
		</script>
		<script>
			// startup - check if we have to run with nodejs prepared data or user loads it in browser
			const uploadControls = document.getElementById('upload-controls');
			const overlay = document.getElementById('blocking-overlay');

			if (window.originalWaterfallData === 'waterfall-data-placeholder') {
				uploadControls.style.display = 'block';
			} else {
				uploadControls.style.display = 'none';
				overlay.style.display = 'none';
				window.waterfallData = { ...originalWaterfallData };
				renderWaterfallImage();
				initCpsControls();
				renderCps();
			}

			function onFileChange(input) {
				const file = input.files[0];
				if (!file) {
					return;
				}

				const reader = new FileReader();
				reader.onload = (e) => {
					overlay.style.display = 'none';
					const fileText = e.target.result;
					const baseSpectrum = exports.deserializeSpectrum(fileText);
					const deltaInfo = exports.deserializeDeltas(fileText, baseSpectrum);
					const deltas = deltaInfo.deltas;

					window.originalWaterfallData = exports.createWaterfallData(baseSpectrum, deltas, 1);
					window.waterfallData = { ...originalWaterfallData };

					resetMovingAverage();
					resetWaterfallBinning();
					waterfallState.channelBinning = 8;
					document.getElementById('channel-binning').value = waterfallState.channelBinning;

					applyBinningAndAverage();
					initCpsControls();
					renderWaterfallImage();
					renderCps();
				};

				reader.readAsText(file);
			}
		</script>
	</body>
</html>